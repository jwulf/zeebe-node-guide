[
{
	"uri": "http://example.org/introduction/zeebe-node/",
	"title": "Zeebe Node",
	"tags": [],
	"description": "",
	"content": "The zeebe-node npm package is an open-source library for creating Node.js Zeebe client applications.\nIt was developed internally at an early-adopter of Zeebe - Credit Sense in Australia - by Josh Wulf. Credit Sense contributed it to the community by making it open-source, and it has gone on to become a popular way to write Zeebe applications.\nIt is written in TypeScript, and can be used with TypeScript or JavaScript.\n"
},
{
	"uri": "http://example.org/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Introduction "
},
{
	"uri": "http://example.org/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Installation Adding the Zeebe Node client to your Node.js project.\n"
},
{
	"uri": "http://example.org/quickstart/",
	"title": "Quick Start",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Quick Start Get a basic Zeebe application running in next to no time.\n"
},
{
	"uri": "http://example.org/zbclient/",
	"title": "ZBClient",
	"tags": [],
	"description": "",
	"content": " Chapter 3 ZBClient The ZBClient class.\n"
},
{
	"uri": "http://example.org/zbworker/",
	"title": "ZBWorker",
	"tags": [],
	"description": "",
	"content": " Chapter 4 ZBWorker The ZBWorker class.\n"
},
{
	"uri": "http://example.org/connection/",
	"title": "Connection",
	"tags": [],
	"description": "",
	"content": " Chapter 5 Connection Using the ZBClient to connect with a Zeebe broker.\n"
},
{
	"uri": "http://example.org/logging/",
	"title": "Logging",
	"tags": [],
	"description": "",
	"content": " Chapter 6 Logging Configuring logging.\n"
},
{
	"uri": "http://example.org/grpc/",
	"title": "gRPC Configuration",
	"tags": [],
	"description": "",
	"content": " Chapter 7 gRPC Configuration Configuring the ZBClient gRPC connection.\n"
},
{
	"uri": "http://example.org/deploywf/",
	"title": "Deploy Workflow Definitions",
	"tags": [],
	"description": "",
	"content": " Chapter 8 Deploy Workflow Definitions Deploying Workflow Definitions to the Broker Cluster.\n"
},
{
	"uri": "http://example.org/installation/install/install/",
	"title": "Install",
	"tags": [],
	"description": "",
	"content": " The Zeebe Node client is available via npm.\nAdd to an existing project npm i zeebe-node  Create a new Node.js project mkdir myproject cd myproject npm init -y npm i zeebe-node  Make it a TypeScript project npm i -g typescript tsc --init  zbctl The zbctl binary is a command-line client that you use to send commands to a Zeebe broker cluster.\nTo install zbctl:\nnpm i -g zbctl  After installation, you can run zbctl and see the available options with:\nzbctl  "
},
{
	"uri": "http://example.org/",
	"title": "Zeebe Node.js Client Guide",
	"tags": [],
	"description": "",
	"content": " Zeebe Node.js Client Guide "
},
{
	"uri": "http://example.org/introduction/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": " Intended Audience This guide is intended for Node.js developers who want to develop Zeebe client applications in JavaScript or TypeScript.\nFamiliarity with ES6 JavaScript or the TypeScript programming language, Node.js, and a working development environment are assumed.\nConfiguring your TypeScript transpilation is out of scope. For that, consult the TypeScript documentation.\nWhat this guide covers This guide walks you through using the JavaScript client for Zeebe, giving you the practical steps to write a fully-fledged Zeebe client application using either ES6 JavaScript or TypeScript.\nIf you want to:\n Evaluate whether Zeebe is a good fit as a solution to your business problem. Build a POC using Zeebe and Node.js. Go to production with a Zeebe solution written in JavaScript / TypeScript.  You\u0026rsquo;ve come to the right place.\nZeebe Broker You will need a running Zeebe broker during development. For instructions on installing a broker for local development and testing, consult the Zeebe broker documentation.\nCode language Code samples are presented in both JavaScript (ES6) and TypeScript, in tabs:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     "
},
{
	"uri": "http://example.org/grpc/grpc/",
	"title": "gRPC",
	"tags": [],
	"description": "",
	"content": " gRPC Communication between your application and the Zeebe broker gateway uses gRPC, a Remote Procedure Call framework that uses a highly efficient binary protocol that multiplexes requests over a persistent HTTP/2 connection.\ngRPC was originally developed at Google for use in their data centers, and is growing in popularity. Its main attractive features are its strong type safety and explicit interface definition through the .proto file, efficiency, and language agnosticism - an important factor in a large polyglot environment like Google, where services written in Go, Java, and C++ all need to talk to each other.\nZeebe was designed to be language agnostic, so gRPC was chosen as the protocol.\nJavaScript doesn\u0026rsquo;t have the same JSON-serialization penalty that these other languages do, so most JavaScript client applications talk JSON over REST, and you may be encountering gRPC for the first time with Zeebe.\nMost of the gRPC nature of the communication with the broker is abstracted away in the Node client, and you will be interacting with idiomatic JavaScript objects.\nWhere the gRPC implementation detail leaks, in our experience, is when the transport layer fails. Using the Node client directly against the broker, this is not noticeable - but in production environments with proxies and load-balancers, you are more likely to become aware that gRPC is the medium.\nFor example: your reverse proxy in production may terminate \u0026ldquo;idle\u0026rdquo; connections at a limit that is shorter than your application\u0026rsquo;s configured polling interval - in which case you will see errors in production that never show up when running directly against an unproxied broker in development.\nThe best advice we can give you is to configure your development environment as close as possible to your production environment - including any reverse proxy configuration - and surface these issues as far forward as you can.\nThe gRPC module The Node client uses the C-based grpc module. There is a pure JavaScript module that we may switch to in the future, but what this means for now is that your node_modules need to be installed in or rebuilt for your run-time environment.\nFor example: you cannot install the Node client on a Windows machine, then mount your working directory into an Ubuntu-based Docker container to run it. The grpc module will need to be rebuilt for Ubuntu in the container using:\nnpm rebuild  "
},
{
	"uri": "http://example.org/connection/connection/",
	"title": "Connection to the Zeebe broker",
	"tags": [],
	"description": "",
	"content": " Broker Gateway address The ZBClient class establishes a connection to a Zeebe broker cluster, and is used to send commands to the broker.\nConceptually, the ZBClient \u0026ldquo;talks to a broker\u0026rdquo;. In practice, the ZBClient talks to a gateway, which handles routing and load-balancing in the broker cluster. This means that you provide a gateway address to the ZBClient. In a development setup, you may have a single broker node with the embedded gateway enabled. In this case you can use the simplest constructor:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     In the absence of any other arguments or environment variables, the ZBClient will communicate with a gateway at 127.0.0.1 on port 26500.\nYou can explicitly provide an address to the constructor if you want. The following examples are functionally equivalent:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // Use default host and port const zbc = new ZBClient() // Use default port const zbc1 = new ZBClient(\u0026#39;127.0.0.1\u0026#39;) const zbc2 = new ZBClient(\u0026#39;localhost\u0026#39;) // Use explicit host and port const zbc1 = new ZBClient(\u0026#39;127.0.0.1:26500\u0026#39;) const zbc3 = new ZBClient(\u0026#39;localhost:26500\u0026#39;) // Use configuration object const zbc4 = new ZBClient({ hostname: \u0026#39;localhost\u0026#39;, port: 26500 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // Use default host and port const zbc = new ZBClient() // Use default port const zbc1 = new ZBClient(\u0026#39;127.0.0.1\u0026#39;) const zbc2 = new ZBClient(\u0026#39;localhost\u0026#39;) // Use explicit host and port const zbc1 = new ZBClient(\u0026#39;127.0.0.1:26500\u0026#39;) const zbc3 = new ZBClient(\u0026#39;localhost:26500\u0026#39;) // Use configuration object const zbc4 = new ZBClient({ hostname: \u0026#39;localhost\u0026#39;, port: 26500 })     Environmentalizing the connection The ZBClient constructor examines the environment for the variable ZEEBE_ADDRESS.\nFor example, given an index.js|ts file like this:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     You can run against a local broker simply with:\nnode index.js  And run the same code against a remote server running on port 80 on zeebe.test.mydomain.com with:\nZEEBE_ADDRESS=zeebe.test.mydomain.com:80 node index.js  "
},
{
	"uri": "http://example.org/connection/tls/",
	"title": "TLS",
	"tags": [],
	"description": "",
	"content": " Connect to a broker with TLS You can secure communication between your client applications and the Zeebe broker cluster using TLS (Transport Layer Security). This needs to be enabled in the broker, or in an reverse proxy, to use.\nBy default, the broker does not secure the client connections with TLS, and the Node client does not use TLS for the connection.\nTo enable TLS with the Node client and connect to a broker secured with TLS, set the option useTLS to true:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // With the default, or a gateway address from the environment const zbc = new ZBClient({ useTLS: true }) // With a gateway address provided in the code const zbc = new ZBClient(gatewayAddress, { useTLS: true })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // With the default, or a gateway address from the environment const zbc = new ZBClient({ useTLS: true }) // With a gateway address provided in the code const zbc = new ZBClient(gatewayAddress, { useTLS: true })     Environmentalizing TLS To enable TLS with the Node client and connect to a broker secured with TLS, set the environment variable ZEEBE_SECURE_CONNECTION:\nZEEBE_SECURE_CONNECTION=true  "
},
{
	"uri": "http://example.org/quickstart/quickstart/",
	"title": "Zeebe Node Quickstart",
	"tags": [],
	"description": "",
	"content": " What you will do in this Quickstart In this Quickstart you will establish a connection to a Zeebe broker cluster, deploy a workflow definition, create instances of that workflow, create a worker to service a task in the workflow, update the workflow variables via a worker, and await a workflow\u0026rsquo;s outcome.\nPrerequisites  Node.js / npm A Zeebe broker running locally (refer to the broker documentation).  Import the Zeebe Node library Create an index.js file (or index.ts for TypeScript).\nEdit the file, and import the Zeebe Node library:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39;   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;)     Create a ZBClient  import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     This establishes a connection to a Zeebe broker running on localhost:26500. This is the default when no arguments are passed to the constructor and no environment variables are set.\nThe connection is eager. This will throw if a broker connection cannot be established - although at this point, this program exits before the connection timeout is reached.\nQuery the broker topology The ZBClient.topology() method queries the broker topology. It returns a Promise of a broker topology object.\nOperations involving the broker are asynchronous. They involve network calls, so they return Promises that need to be awaited, or composed using Promise.then.\nHere we query the broker topology using the Promise interface:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() zbc.topology() .catch(console.error) .then(res =\u0026gt; console.log(JSON.stringify(res, null, 2)))  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() zbc.topology() .catch(console.error) .then(res =\u0026gt; console.log(JSON.stringify(res, null, 2)))     For the rest of this guide, we will mostly be using the async/await approach to Promise handling in examples.\nHere is the same code to query the broker topology, written using async/await syntax:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { const res = await zbc.topology() console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { const res = await zbc.topology() console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     You can use either style in your code.\nOutput: Query the broker topology If the broker is running and accessible, you will see something like the following:\n{ \u0026quot;brokers\u0026quot;: [ { \u0026quot;partitions\u0026quot;: [ { \u0026quot;partitionId\u0026quot;: 1, \u0026quot;role\u0026quot;: \u0026quot;LEADER\u0026quot; } ], \u0026quot;nodeId\u0026quot;: 0, \u0026quot;host\u0026quot;: \u0026quot;172.24.0.2\u0026quot;, \u0026quot;port\u0026quot;: 26501 } ], \u0026quot;clusterSize\u0026quot;: 1, \u0026quot;partitionsCount\u0026quot;: 1, \u0026quot;replicationFactor\u0026quot;: 1 }  Note: if the broker is running in Docker, the host IP address reported by the topology command is the internal Docker network IP of the broker.\nNetwork errors and automatic retries If the broker is not started, or is not accessible to your client, you will see a stream of errors - similar to the one below - that slow down over time.\n{\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-21T13:52:00.961Z\u0026quot;,\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:433\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;[topology]: Attempt 5 (max: 50).\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-21 23:52:00PM\u0026quot;,\u0026quot;pollInterval\u0026quot;:30000,\u0026quot;namespace\u0026quot;:\u0026quot;ZBClient\u0026quot;} {\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-21T13:52:00.962Z\u0026quot;,\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:441\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;[topology]: 14 UNAVAILABLE: failed to connect to all addresses\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-21 23:52:00PM\u0026quot;,\u0026quot;pollInterval\u0026quot;:30000,\u0026quot;namespace\u0026quot;:\u0026quot;ZBClient\u0026quot;}  These are due to the Zeebe Node client\u0026rsquo;s built-in backoff-retry logic for network-related errors. The client automatically retries to establish the connection until it connects, or retries are exhausted.\nYou can disable automatic retries if you want network errors to bubble up immediately to your code, and write your own logic to handle them. See the later section on gRPC configuration for more details.\nLogs The client logs to the console by default (you can inject a replacement), using a structured JSON format - ndjson. To view the log output in a human-readable format, you can use pino-pretty.\nInstall pino-pretty globally:\n npm i -g pino-pretty     Now, pipe your program\u0026rsquo;s output through pino-pretty:\n node index.js | pino-pretty     Log messages will now be formatted for your viewing pleasure:\n[2019 Nov-21 23:52:54PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:433\u0026quot; message: \u0026quot;[topology]: Attempt 5 (max: 50).\u0026quot; pollInterval: 30000 namespace: \u0026quot;ZBClient\u0026quot; [2019 Nov-21 23:52:54PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:441\u0026quot; message: \u0026quot;[topology]: 14 UNAVAILABLE: failed to connect to all addresses\u0026quot; pollInterval: 30000 namespace: \u0026quot;ZBClient\u0026quot;  Deploy a Workflow Definition The next task is to deploy a workflow definition to the broker.\nThe method ZBClient.deployWorkflow() takes a path to a .bpmn file, and deploys that BPMN file to the broker, returning a Promise of a broker response - a DeployWorkflowResponse.\nHere is the sample workflow definition that we will be using:\nIt has a single task in it.\nDownload the sample bpmn file from this bpmn-sample GitHub repository.\nIf you are using JavaScript or transpiling TypeScript in-place (outputting the .js files next to the .ts source files), then put the .bpmn file in the same directory as your index file. You will need to use the path ./sample.bpmn.\nIf you are transpiling your TypeScript from a source directory to an output directory, then put the .bpmn file in the directory above your source directory. You will need to use the path ../sample.bpmn.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { const res = await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { const res = await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     Output: Deploy a Workflow Definition You will see output similar to the following:\n{ \u0026quot;workflows\u0026quot;: [ { \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;version\u0026quot;: 1, \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813685249\u0026quot;, \u0026quot;resourceName\u0026quot;: \u0026quot;sample.bpmn\u0026quot; } ], \u0026quot;key\u0026quot;: \u0026quot;2251799813685250\u0026quot; }  The workflow has been deployed to the broker, and you can now start an instance of the workflow, using its bpmnProcessId - \u0026ldquo;sample-process\u0026rdquo; (this is defined in the .bpmn file).\nCreate a Workflow Instance The method ZBClient.createWorkflowInstance() creates (and starts) a workflow instance. It takes a BPMN Process Id and an initial variables object, and returns a Promise of a CreateWorkflowInstance response.\nThere is no problem leaving the deployWorkflow command in the code - the broker will not update the deployment if the file has not changed since the last deployment, and it ensures that the workflow definition we are about to start an instance of is, in fact, deployed.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstance(\u0026#39;sample-process\u0026#39;, {}); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstance(\u0026#39;sample-process\u0026#39;, {}); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     Output: Create a Workflow Instance You will see output similar to the following:\n{ \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813685249\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;version\u0026quot;: 1, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813685252\u0026quot; }  An instance of the workflow has been started.\nCreate a Worker A worker is a process that subscribes to a task type on the broker, polling for available jobs of that task type. When jobs of that task type are available, the broker streams them to the worker in response to its polling request. The workflow\u0026rsquo;s job handler is invoked for each available job.\nThe method ZBClient.createWorker creates a new worker. It takes an optional worker id for tracing, a task type, and a job handler callback function. If the worker id is null, the library will assign a UUID.\nCreate a new file named worker.js (worker.ts for TypeScript).\nEdit the content like this:\n import { ZBClient } from \u0026#34;zeebe-node\u0026#34;; const zbc = new ZBClient(); zbc.createWorker(null, \u0026#34;sample-task\u0026#34;, (job, complete) =\u0026gt; { console.log(JSON.stringify(job, null, 2)); // Business logic  complete.success(); });  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient(); zbc.createWorker(null, \u0026#34;sample-task\u0026#34;, (job, complete) =\u0026gt; { console.log(JSON.stringify(job, null, 2)); // Business logic  complete.success(); });     When you run this, the worker polls the broker for jobs of type \u0026lsquo;sample-task\u0026rsquo;, and gets the job from the workflow you created in a previous step.\nOutput: Create a Worker You will see output similar to the following:\n{ \u0026quot;key\u0026quot;: \u0026quot;2251799813686445\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;sample-task\u0026quot;, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813686440\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;workflowDefinitionVersion\u0026quot;: 1, \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813686430\u0026quot;, \u0026quot;elementId\u0026quot;: \u0026quot;ServiceTask_1aj1tsb\u0026quot;, \u0026quot;elementInstanceKey\u0026quot;: \u0026quot;2251799813686444\u0026quot;, \u0026quot;customHeaders\u0026quot;: {}, \u0026quot;worker\u0026quot;: \u0026quot;559fe180-c860-44ba-a6c5-8d32d6b9e026\u0026quot;, \u0026quot;retries\u0026quot;: 3, \u0026quot;deadline\u0026quot;: \u0026quot;1574076501831\u0026quot;, \u0026quot;variables\u0026quot;: {} }  This is the job object that is received by the worker. Your worker can perform any side-effects and any calculations it needs to, and post any updates to the job variables.\nYour worker is sitting there polling for more work, so you can experiment with starting more workflows. Hit Ctrl-C to kill the worker when you are ready to move on.\nUpdate the job This next step requires 0.22.0-alpha1 or later of the broker, and v0.22.0-alpha.1 or later of the Node client. We are going to use the createWorkflowInstanceWithResult() method of the client to await the outcome of the workflow. This method was introduced with that version and does not work in earlier versions.\nFirst, modify your worker like this:\n import { ZBClient } from \u0026#34;zeebe-node\u0026#34;; const zbc = new ZBClient(); zbc.createWorker(null, \u0026#34;sample-task\u0026#34;, (job, complete) =\u0026gt; { console.log(JSON.stringify(job, null, 2)); // Business logic  complete.success({ updateId: \u0026#39;some-uuid\u0026#39; }); });  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient(); zbc.createWorker(null, \u0026#34;sample-task\u0026#34;, (job, complete) =\u0026gt; { console.log(JSON.stringify(job, null, 2)); // Business logic  complete.success({ updateId: \u0026#39;some-uuid\u0026#39; }); });     Here, we update the workflow variables from the worker. This update will be merged with the other variables in the workflow and will be the job variables that workers servicing tasks later in the process receive. There is only one task in our sample workflow, so we will use a method call that starts a workflow and awaits the result to inspect the variable state after our worker does its thing.\nStart the worker now, and modify index.js|ts to be this:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstanceWithResult(\u0026#39;sample-process\u0026#39;, { requestId: \u0026#39;someRequestId\u0026#39; }); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstanceWithResult(\u0026#39;sample-process\u0026#39;, { requestId: \u0026#39;someRequestId\u0026#39; }); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     Output: Update the job You will see output similar to the following in the worker:\n{ \u0026quot;key\u0026quot;: \u0026quot;2251799813686671\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;sample-task\u0026quot;, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813686665\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;workflowDefinitionVersion\u0026quot;: 1, \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813686430\u0026quot;, \u0026quot;elementId\u0026quot;: \u0026quot;ServiceTask_1aj1tsb\u0026quot;, \u0026quot;elementInstanceKey\u0026quot;: \u0026quot;2251799813686670\u0026quot;, \u0026quot;customHeaders\u0026quot;: {}, \u0026quot;worker\u0026quot;: \u0026quot;819f09a4-7fde-4782-808d-9ed86c8ee363\u0026quot;, \u0026quot;retries\u0026quot;: 3, \u0026quot;deadline\u0026quot;: \u0026quot;1574079338555\u0026quot;, \u0026quot;variables\u0026quot;: { \u0026quot;requestId\u0026quot;: \u0026quot;someRequestId\u0026quot; } }  We created the workflow instance with variable requestId set to someRequestId, and you can see that your worker receives this in the job variables.\nWhen the worker completes the job, it sends back an update: it sets updateId to some-uuid. In your process that creates and awaits the workflow, you will see something similar to the following:\n{ \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813686430\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;version\u0026quot;: 1, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813686665\u0026quot;, \u0026quot;variables\u0026quot;: { \u0026quot;updateId\u0026quot;: \u0026quot;some-uuid\u0026quot;, \u0026quot;requestId\u0026quot;: \u0026quot;someRequestId\u0026quot; } }  The workflow variables were updated.\nSummary In this Quickstart you deployed a workflow definition, created instances of that workflow, created a worker to service the single task in the workflow, updated job variables, and awaited a workflow\u0026rsquo;s outcome.\nThis is 80% of what you\u0026rsquo;ll be doing with the Zeebe Node client in your application.\nThe rest of this guide goes into more depth on each of these aspects, and also covers the other methods that are available.\n"
},
{
	"uri": "http://example.org/introduction/not-rest/",
	"title": "Zeebe client applications",
	"tags": [],
	"description": "",
	"content": " Zeebe is a highly-scalable, cloud-native microservices orchestration engine that uses BPMN to orchestrate microservices.\nPolling model Zeebe clients communicate with a Zeebe broker cluster through a gateway. Communication between the JavaScript client code and the gateway is over gRPC. That means that your client applications poll the gateway for available tasks. The Zeebe broker does not invoke your microservices over REST. If you come from a REST architecture background, or have an existing REST microservices architecture that you want to orchestrate, you should take the time to understand the Zeebe model as it is, before trying to figure out how to use it with RESTful services. It is definitely possible, but you need to wire it up to work.\nThink of it like this: your Zeebe worker, written in JavaScript, subscribes to a task type on the gateway. It then runs in a loop, polling the gateway for that task type. When jobs of that task type are available, the gateway returns them to the worker. If you have an existing RESTful microservice that you want to invoke for jobs of that task type, then your Zeebe worker can invoke it. And that\u0026rsquo;s how you wire up Zeebe with existing RESTful microservices.\nYou could do something like create a worker that subscribes to many task types and has a map for the task type to the REST endpoint that should be invoked for it.\nThe important thing to understand is that workers subscribe to a task type, and poll for jobs of that task type. So it is a pull model, rather than the push model of REST, where the broker would invoke a REST service.\nThe pull model means that you can scale the workers without configuring routing or load-balancing, as you would need to do if it were a push model.\nIf you are writing a system from scratch, then you can put your business logic directly in a polling worker - or you can put the business logic in a REST endpoint if you need to reuse it from other places, and wrap the REST call in a Zeebe worker.\n"
},
{
	"uri": "http://example.org/connection/basic-auth/",
	"title": "Basic Auth",
	"tags": [],
	"description": "",
	"content": " Connect to a broker with Basic Auth You can secure a Zeebe cluster with Basic Auth using an reverse proxy. In this case you can use a username / password pair as effectively an API key for your client applications.\nBasic Auth without TLS To enable Basic Auth without TLS:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ basicAuth: { username: \u0026#39;basicAuth-username\u0026#39;, password: \u0026#39;basicAuth-password\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 80 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ basicAuth: { username: \u0026#39;basicAuth-username\u0026#39;, password: \u0026#39;basicAuth-password\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 80 })     Basic Auth with TLS To enable Basic Auth with TLS:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ basicAuth: { username: \u0026#39;basicAuth-username\u0026#39;, password: \u0026#39;basicAuth-password\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443, useTLS: true })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ basicAuth: { username: \u0026#39;basicAuth-username\u0026#39;, password: \u0026#39;basicAuth-password\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443, useTLS: true })     Environmentalizing Basic Auth configuration The following environment variables control Basic Auth configuration:\nZEEBE_BASIC_AUTH_USERNAME ZEEBE_BASIC_AUTH_PASSWORD  To enable TLS on the connection:\nZEEBE_SECURE_CONNECTION=true  "
},
{
	"uri": "http://example.org/deploywf/deploy/",
	"title": "Deploy Workflow Definitions",
	"tags": [],
	"description": "",
	"content": " Workflow Definitions Workflow definitions are XML files that specify a process using the BPMN (Business Process Model and Notation) schema with Zeebe extensions.\nYou can create and edit these files using the graphical Zeebe modeler.\nDeploy workflow definition files The method ZBClient.deployWorkflow can take a string or an array of strings, where each string is a file path to a BPMN file containing a workflow definition to deploy:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import path from \u0026#39;path\u0026#39; const zbc = new ZBClient() async function deployMyWorkflowDefinition(filepaths: string | string[]) { const res = await zbc.deployWorkflow(filepaths) console.log(res) return res } deployMyWorkflowDefinition( path.join( __dirname, \u0026#39;..\u0026#39;, \u0026#39;bpmn\u0026#39;, \u0026#39;my-workflow.bpmn\u0026#39; ))  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const path = require(\u0026#39;path\u0026#39;) const zbc = new ZBClient() async function deployMyWorkflowDefinition(filepaths) { const res = await zbc.deployWorkflow(filepaths) console.log(res) return res } deployMyWorkflowDefinition( path.join( __dirname, \u0026#39;..\u0026#39;, \u0026#39;bpmn\u0026#39;, \u0026#39;my-workflow.bpmn\u0026#39; ))     The deployWorkflow command returns a DeployWorkflowResponse. This has an array of WorkflowMetadata, containing information about the workflow definitions deployed.\nThe method will throw if any of the workflow definitions are malformed - in this case none are deployed. @TODO - verify\nNote on versioning: Re-deploying a workflow definition does not create a new version of that workflow definition in the broker cluster, unless the definition has been modified - in which case a new version is created.\nDeploy a workflow definition from an in-memory buffer ZBClient.deployWorkflow can also deploy a workflow definition from an in-memory buffer.\nThis is useful if, for example, you perform template processing on a workflow definition after loading it from a file, before deploying it. See here for an example of doing that with micromustache.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import { transformWfd } from \u0026#39;./my-workflow-transformer\u0026#39; import fs from \u0026#39;fs\u0026#39;; import path from \u0026#39;path\u0026#39; const zbc = new ZBClient() async function deployMyWorkflowDefinition(filepath: string) { const workflow = fs.readFileSync(filepath, \u0026#39;utf-8\u0026#39;) const xFormedWfd = transformWfd(workflow) const res = await zbc.deployWorkflow({ definition: Buffer.from(xFormedWfd), name: path.basename(filepath) }) console.log(res) return res } deployMyWorkflowDefinition( path.join( __dirname, \u0026#39;..\u0026#39;, \u0026#39;bpmn\u0026#39;, \u0026#39;my-workflow.bpmn\u0026#39; ))  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) import { transformWfd } from \u0026#39;./my-workflow-transformer\u0026#39; import fs from \u0026#39;fs\u0026#39;; const path = require(\u0026#39;path\u0026#39;) const zbc = new ZBClient() async function deployMyWorkflowDefinition(filepath: string) { const workflow = fs.readFileSync(filepath, \u0026#39;utf-8\u0026#39;) const xFormedWfd = transformWfd(workflow) const res = await zbc.deployWorkflow({ definition: Buffer.from(xFormedWfd), name: path.basename(filepath) }) console.log(res) return res } deployMyWorkflowDefinition( path.join( __dirname, \u0026#39;..\u0026#39;, \u0026#39;bpmn\u0026#39;, \u0026#39;my-workflow.bpmn\u0026#39; ))     "
},
{
	"uri": "http://example.org/logging/logging/",
	"title": "Logging",
	"tags": [],
	"description": "",
	"content": " Log format The Node client logs its messages using a structured JSON format - ndjson. These messages are designed to be easily parsed by scripts.\nThe messages are output to the console by default, and look like this:\n{\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-21T13:52:00.961Z\u0026quot;,\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:433\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;[topology]: Attempt 5 (max: 50).\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-21 23:52:00PM\u0026quot;,\u0026quot;pollInterval\u0026quot;:30000,\u0026quot;namespace\u0026quot;:\u0026quot;ZBClient\u0026quot;} {\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-21T13:52:00.962Z\u0026quot;,\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:441\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;[topology]: 14 UNAVAILABLE: failed to connect to all addresses\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-21 23:52:00PM\u0026quot;,\u0026quot;pollInterval\u0026quot;:30000,\u0026quot;namespace\u0026quot;:\u0026quot;ZBClient\u0026quot;}  To view log messages in a human-readable format, you can pipe your program\u0026rsquo;s output through pino-pretty. This results in output like this:\n[2019 Nov-21 23:52:54PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:433\u0026quot; message: \u0026quot;[topology]: Attempt 5 (max: 50).\u0026quot; pollInterval: 30000 namespace: \u0026quot;ZBClient\u0026quot; [2019 Nov-21 23:52:54PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:441\u0026quot; message: \u0026quot;[topology]: 14 UNAVAILABLE: failed to connect to all addresses\u0026quot; pollInterval: 30000 namespace: \u0026quot;ZBClient\u0026quot;  Log message levels There are three levels of log messages:\n 20 - DEBUG 30 - INFO 50 - ERROR  Set the logging level By default, the client logs at INFO level.\nSet the log level of the ZBClient to one of the log levels - DEBUG, INFO, ERROR; or to NONE to suppress all logging.\nYou can set the logging level of the ZBClient via the ZBClient constructor:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // Suppress all log messages except errors const zbc = new ZBClient({ loglevel: \u0026#39;ERROR\u0026#39; })  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // Suppress all log messages except errors const zbc = new ZBClient({ loglevel: \u0026#39;ERROR\u0026#39; })     And via the environment:\nZEEBE_NODE_LOG_LEVEL  Any environment setting will override the constructor setting. This is the only setting with this precedence.\nSet a custom log namespace By default, the ZBClient logs with namespace \u0026ldquo;ZBClient\u0026rdquo;. If you have more than one ZBClient instance in your application, you can distinguish between them by setting a custom log namespace. Pass a string or array of strings to the ZBClient constructor as the logNamespace parameter.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ logNamespace: \u0026#39;zbc\u0026#39; }) const zbc1 = new ZBClient({ logNamespace: \u0026#39;zbc1\u0026#39; })  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ logNamespace: \u0026#39;zbc\u0026#39; }) const zbc1 = new ZBClient({ logNamespace: \u0026#39;zbc1\u0026#39; })     Log to a custom stdout You can redirect the log output to somewhere other than the console by passing in an object with an info method that takes a string parameter.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import { postMessage } from \u0026#39;./my-http-log-sink\u0026#39; // Use a custom log sink const zbc = new ZBClient({ loglevel: \u0026#39;ERROR\u0026#39;, stdio: { info: msg =\u0026gt; postMessage(msg) } })  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const { postMessage } = require(\u0026#39;./my-http-log-sink\u0026#39;) // Use a custom log sink const zbc = new ZBClient({ loglevel: \u0026#39;ERROR\u0026#39;, stdio: { info: msg =\u0026gt; postMessage(msg) } })     For an example of a custom logger, see the implementation in the Node-RED Zeebe package.\nLogging in ZBWorker The ZBWorker inherits its log settings from the ZBClient that creates it. You can also override any of the settings in the createWorker method call.\nBy default the ZBWorker logs with the namespace \u0026ldquo;ZBWorker\u0026rdquo;. If a custom namespace has been set for the ZBClient, the ZBWorker inherits it and prepends \u0026ldquo;ZBWorker\u0026rdquo; to it. If you override this with an explicit namespace, \u0026ldquo;ZBWorker\u0026rdquo; is prepended to that.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import { jobhandler } from \u0026#39;./jobhandler\u0026#39; const zbc = new ZBClient({ logNamespace: \u0026#39;Main ZBClient\u0026#39;, }) // Logs with namespace \u0026#34;ZBWorker override-namespace\u0026#34; const worker = zbc.createWorker(null, \u0026#39;get-user\u0026#39;, jobhandler, { logNamespace: \u0026#39;override-namespace\u0026#39; })  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const { jobhandler } = require(\u0026#39;./jobhandler\u0026#39;) const zbc = new ZBClient({ logNamespace: \u0026#39;Main ZBClient\u0026#39;, }) // Logs with namespace \u0026#34;ZBWorker override-namespace\u0026#34; const worker = zbc.createWorker(null, \u0026#39;get-user\u0026#39;, jobhandler, { logNamespace: \u0026#39;override-namespace\u0026#39; })     "
},
{
	"uri": "http://example.org/connection/oauth/",
	"title": "OAuth",
	"tags": [],
	"description": "",
	"content": " Connect to a broker with OAuth You can secure a Zeebe cluster with OAuth using a proxy. In this case, the Node client can retrieve a JWT (JSON Web Token) from a token endpoint to use to authorize requests to the broker.\nIf you are using OAuth, you are probably using TLS as well, so TLS is automatically enabled when OAuth is configured. You need to explicitly disable TLS if you are using OAuth without TLS, and re-examine your life choices (I\u0026rsquo;m kidding - this is for a development POC \u0026hellip;right??).\nIn the following example, we enable OAuth:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ oAuth: { url: \u0026#39;my-oAuth-endpoint.com\u0026#39;, audience: \u0026#39;token-audience\u0026#39;, clientId: \u0026#39;oAuth-client-id\u0026#39;, clientSecret: \u0026#39;oAuth-client-secret\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ oAuth: { url: \u0026#39;my-oAuth-endpoint.com\u0026#39;, audience: \u0026#39;token-audience\u0026#39;, clientId: \u0026#39;oAuth-client-id\u0026#39;, clientSecret: \u0026#39;oAuth-client-secret\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443 })     Environmentalizing OAuth configuration The following environment variables control OAuth configuration:\nZEEBE_TOKEN_AUDIENCE ZEEBE_AUTHORIZATION_SERVER_URL ZEEBE_CLIENT_ID ZEEBE_CLIENT_SECRET  OAuth JWT caching The Node client caches the JWT in-memory, and only requests a new token when the current token expires. This is important for performance, as the client doesn\u0026rsquo;t need to request a token for each request. This speeds up network requests to the gateway and reduces calls to your token-issuing endpoint.\nThe Node client also caches the token on disk. This is important in development when you are restarting your application frequently, and also when running in a stateless environment like AWS Lambda.\nBy default, the JWT is cached in the directory ~/.camunda. In some environments (such as AWS Lambda) this directory is not writable. To avoid unbounded token requests, the ZBClient will throw in its constructor if it cannot write to the token cache directory.\nYou can configure a custom token cache directory in the oAuth configuration using the optional cacheDir parameter, like this:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ useTLS: true, oAuth: { url: \u0026#39;my-oAuth-endpoint.com\u0026#39;, audience: \u0026#39;token-audience\u0026#39;, clientId: \u0026#39;oAuth-client-id\u0026#39;, clientSecret: \u0026#39;oAuth-client-secret\u0026#39;, cacheDir: \u0026#39;/cache\u0026#39; }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ useTLS: true, oAuth: { url: \u0026#39;my-oAuth-endpoint.com\u0026#39;, audience: \u0026#39;token-audience\u0026#39;, clientId: \u0026#39;oAuth-client-id\u0026#39;, clientSecret: \u0026#39;oAuth-client-secret\u0026#39;, cacheDir: \u0026#39;/cache\u0026#39; }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443 })     Environmentalizing JWT cache The following environment variable overrides the JWT cache directory:\nZEEBE_TOKEN_CACHE_DIR  "
},
{
	"uri": "http://example.org/zbclient/zbclient/",
	"title": "ZBClient class",
	"tags": [],
	"description": "",
	"content": "The ZBClient is the main class in the Node client. It is used to connect to the broker, deploy workflow definitions, start workflow instances, publish messages, and to create workers (ZBWorker) that will service Zeebe tasks.\nThe workers created from the Zeebe client inherit the client\u0026rsquo;s settings, allowing you to consolidate your configuration. At the same time, you can override those settings for any worker - so you have convenience and flexibility.\n"
},
{
	"uri": "http://example.org/grpc/grpc-config/",
	"title": "ZBClient gRPC retries",
	"tags": [],
	"description": "",
	"content": " Failure - part of success All ZBClient methods that involve sending a gRPC command to the broker may fail.\nIf you are using async/await that means they will throw. If you are using Promises, they will reject and take the .catch path.\nWe divide failures into two categories:\n \u0026ldquo;Business logic errors\u0026rdquo; - for example, trying to create an instance of a workflow for which no workflow definition is deployed on the broker. \u0026ldquo;Network errors\u0026rdquo; - for example, the gRPC connection to the gateway is in a failed state while the gateway is being rescheduled by Kubernetes.  Business errors will always throw / reject.\nThe Node client can automatically retry on network errors, and does this by default.\nAutomatic retry on network errors Network errors return gRPC error code 14.\nAccording to the spec:\n The service is currently unavailable. This is most likely a transient condition, which can be corrected by retrying with a backoff. Note that it is not always safe to retry non-idempotent operations.\n To help you write robust applications that continue to operate around transient network failures and recover automatically as the network recovers, the Node client is configured by default to automatically retry operations on network failures, with a back-off.\nDisable automatic retries You can configure this, or disable it entirely if you want to code some other strategy. If you need your application to page you immediately on a network error, and definitely do not try that again (or some other custom handling), pass retry: false to the ZBClient constructor:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // Don\u0026#39;t retry. I will handle all errors. const zbc = new ZBClient({ retry: false })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // Don\u0026#39;t retry. I will handle all errors. const zbc = new ZBClient({ retry: false })     Note that you can create more than one ZBClient in an application, each with its own retry configuration, and then use the retry strategy that makes sense for each operation.\nConfigure retries If you have retries enabled, you can set the maximum number of retries that are attempted before an exception is thrown, and the maximum time between retries.\nThe retry mechanism is implemented using the promise-retry module. The backoff is exponential by a factor of 2, and by default it retries 50 times, with a maximum of 5 seconds between retries.\nTo change this, pass in values for maxRetries and maxRetryTimeout to the ZBClient constructor:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // These are the default settings. const zbc = new ZBClient({ maxRetries: 50 maxRetryTimeout: 5000 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // These are the default settings. const zbc = new ZBClient({ maxRetries: 50 maxRetryTimeout: 5000 })     Broker backpressure There is a third category of response that can be handled with automated retries. The Zeebe broker has an adaptive algorithm that detects growing latency in the system due to load, and produces backpressure. When the broker detects this, it responds to commands (other than completeJob) with gRPC error code 8 - RESOURCE EXHAUSTED.\nIf retries are enabled, in this situation the Node client applies the same retry strategy that is configured for transient network failures.\n"
},
{
	"uri": "http://example.org/logging/zblogger/",
	"title": "ZBLogger",
	"tags": [],
	"description": "",
	"content": "The ZBLogger class is available for you to use for logging in your application.\n import { ZBLogger } from \u0026#39;zeebe-node\u0026#39; const logger = new ZBLogger({ loglevel: \u0026#39;INFO\u0026#39;, namespace: \u0026#39;my-application-context\u0026#39;, }) logger.info(\u0026#39;Starting...\u0026#39;)  const { ZBLogger } = require(\u0026#39;zeebe-node\u0026#39;) const logger = new ZBLogger({ loglevel: \u0026#39;INFO\u0026#39;, namespace: \u0026#39;my-application-context\u0026#39;, }) logger.info(\u0026#39;Starting...\u0026#39;)     "
},
{
	"uri": "http://example.org/zbworker/zbworker/",
	"title": "ZBWorker class",
	"tags": [],
	"description": "",
	"content": "The ZBWorker is the class used to create Zeebe Job workers.\nYour Workflow Definitions contain tasks. A task has a task type.\nWhen you create a workflow instance, the broker will create a job for a task. A job is a specific concrete instance of a task.\nAn ZBWorker instance subscribes to the gateway for jobs of a specific task type, and continually polls the gateway for available jobs. When there is work for the worker to do, the gateway responds to the poll with a stream of jobs, and the worker\u0026rsquo;s job handler is invoked for each job.\n"
},
{
	"uri": "http://example.org/connection/camunda-cloud/",
	"title": "Camunda Cloud",
	"tags": [],
	"description": "",
	"content": " Connect to Camunda Cloud Camunda Cloud provides a fully managed Zeebe service with TLS and OAuth.\nClient version 0.22 and above The Zeebe Node client version 0.22 and above provides a convenience that handles the TLS and some of the OAuth configuration for Camunda Cloud.\nTo use with Camunda Cloud, set these values in code. Note that cacheDir is optional, and should be used when the directory ~ is not writable in your runtime environment, to set a custom token cache directory.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // cacheDir is optional - see OAuth JWT caching const zbc = new ZBClient({ camundaCloud: { clientId: \u0026#39;yStuGvJ6a1RQhy8DQpeXJ80yEpar3pXh\u0026#39;, clientSecret: \u0026#39;WZahIGHjyj0-oQ7DZ_aH2wwNuZt5O8Sq0ZJTz0OaxfO7D6jaDBZxM_Q-BHRsiGO_\u0026#39;, clusterId: \u0026#39;103ca930-6da6-4df7-aa97-941eb1f85040\u0026#39;, cacheDir: \u0026#39;./tokens\u0026#39; } })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // cacheDir is optional - see OAuth JWT caching const zbc = new ZBClient({ camundaCloud: { clientId: \u0026#39;yStuGvJ6a1RQhy8DQpeXJ80yEpar3pXh\u0026#39;, clientSecret: \u0026#39;WZahIGHjyj0-oQ7DZ_aH2wwNuZt5O8Sq0ZJTz0OaxfO7D6jaDBZxM_Q-BHRsiGO_\u0026#39;, clusterId: \u0026#39;103ca930-6da6-4df7-aa97-941eb1f85040\u0026#39;, cacheDir: \u0026#39;./tokens\u0026#39; } })     Environmentalizing Camunda Cloud (client version \u0026gt;= 0.22) To use Camunda Cloud with clients version 0.22 and above, set the environment variables:\nZEEBE_ADDRESS # Set with \u0026quot;Zeebe Cluster Id\u0026quot; value ZEEBE_CLIENT_ID # Set with \u0026quot;clientId\u0026quot; value ZEEBE_CLIENT_SECRET # Set with \u0026quot;clientSecret\u0026quot; value  Setting only these three OAuth values is interpreted by the client as necessary and sufficient for Camunda Cloud, and it will enable TLS and correctly set the OAuth token audience and Authorization URL.\nOptionally, set a custom token cache directory:\nZEEBE_TOKEN_CACHE_DIR  Client version prior to 0.22 The OAuth authorization endpoint changed in November 2019. Client versions prior to 0.22 are hard-coded to use the previous authorization endpoint, so the convenience configuration will not work. You will need to provide all the configuration details.\nThe oAuth.url is a constant - it\u0026rsquo;s the Camunda Cloud token endpoint. The other values depend on your cluster, and come from your Camunda Cloud account. The oAuth.audience needs to be set to your cluster Id with the .zeebe.camunda.io domain added to it.\nThe oAuth.cacheDir setting is optional, and should be set if the directory ~ is not writable in your run-time environment - for example, AWS Lambda with the default mounts.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ useTLS: true, oAuth: { url: \u0026#39;@TODO my-oAuth-endpoint.com\u0026#39;, audience: \u0026#39;103ca930-6da6-4df7-aa97-941eb1f85040.zeebe.camunda.io\u0026#39;, clientId: \u0026#39;yStuGvJ6a1RQhy8DQpeXJ80yEpar3pXh\u0026#39;, clientSecret: \u0026#39;WZahIGHjyj0-oQ7DZ_aH2wwNuZt5O8Sq0ZJTz0OaxfO7D6jaDBZxM_Q-BHRsiGO_\u0026#39;, clusterId: \u0026#39;103ca930-6da6-4df7-aa97-941eb1f85040\u0026#39;, cacheDir: \u0026#39;/cache\u0026#39; }, hostname: \u0026#39;103ca930-6da6-4df7-aa97-941eb1f85040.zeebe.camunda.io\u0026#39;, port: 443 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ useTLS: true, oAuth: { url: \u0026#39;@TODO my-oAuth-endpoint.com\u0026#39;, audience: \u0026#39;103ca930-6da6-4df7-aa97-941eb1f85040.zeebe.camunda.io\u0026#39;, clientId: \u0026#39;yStuGvJ6a1RQhy8DQpeXJ80yEpar3pXh\u0026#39;, clientSecret: \u0026#39;WZahIGHjyj0-oQ7DZ_aH2wwNuZt5O8Sq0ZJTz0OaxfO7D6jaDBZxM_Q-BHRsiGO_\u0026#39;, clusterId: \u0026#39;103ca930-6da6-4df7-aa97-941eb1f85040\u0026#39;, cacheDir: \u0026#39;/cache\u0026#39; }, hostname: \u0026#39;103ca930-6da6-4df7-aa97-941eb1f85040.zeebe.camunda.io\u0026#39;, port: 443 })     Environmentalizing Camunda Cloud (client version \u0026lt; 0.22) For clients prior to 0.22, you need to set all the environment variables for oAuth, using the appropriate values for Camunda Cloud and your cluster. See above for how you get those.\nZEEBE_TOKEN_AUDIENCE ZEEBE_AUTHORIZATION_SERVER_URL=@TODO ZEEBE_CLIENT_ID ZEEBE_CLIENT_SECRET  Optionally, set a custom token cache directory:\nZEEBE_TOKEN_CACHE_DIR  "
},
{
	"uri": "http://example.org/zbclient/configuration/",
	"title": "Configuration Strategies",
	"tags": [],
	"description": "",
	"content": " Zero-conf constructor vs configuration in code You can provide configuration to the ZBClient explicitly in your code - via the constructor - or via environment variables.\nExplicit configuration in code is quick and easy, and makes sense when you are first experimenting with Zeebe.\nWe recommend, however, that ultimately you use the zero-conf constructor, and provide all the configuration via environment variables, docker-compose.yml, or a K8s config map. This environmentalizes your configuration, making your code portable.\nWhen you deploy your application to a test, staging, or production environment, no changes are required in your code: you will be testing the exact code you run in production, and you can use configuration management tools to handle the different environments.\nNote that any explicit configuration in code overrides configuration from the environment - with one exception: the log level can be overridden from the environment.\n"
},
{
	"uri": "http://example.org/grpc/grpc-events/",
	"title": "ZBClient gRPC channel events",
	"tags": [],
	"description": "",
	"content": " ZBClient gRPC channel events The ZBClient notifies on gRPC channel connection failure and reconnection. In addition to wrapping every single operation, you can use this feature to write alerting or custom behavior based on the underlying connection status.\nOne thing to bear in mind is that ZBClient operations will throw if they encounter an error. However, there is no opportunity to be alerted to a network failure until you try an operation.\nThe ZBClient gRPC channel events allow you to detect and react to network disruption independent of operations.\nThere are two interfaces to the ZBClient gRPC events: callbacks and events.\nonReady and onConnectionError callbacks The onReady callback is called when the ZBClient gRPC connection is initially established, and every time it is re-established after it is disconnected.\nNote that the ZBClient constructor immediately issues a topology command to the broker to provoke an error or prove the connection. Without this, the channel status is unknown until the first command is issued.\nThe onConnectionError callback is called when the gRPC channel is disconnected.\nPass in callbacks to the ZBClient constructor to react on these events:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ onReady: () =\u0026gt; console.log(\u0026#39;Ready for action!\u0026#39;), onConnectionError: () =\u0026gt; console.log(\u0026#39;Boo! The gRPC connection failed!\u0026#39;) })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ onReady: () =\u0026gt; console.log(\u0026#39;Ready for action!\u0026#39;), onConnectionError: () =\u0026gt; console.log(\u0026#39;Boo! The gRPC connection failed!\u0026#39;) })     \u0026lsquo;ready\u0026rsquo; and \u0026lsquo;connectionError\u0026rsquo; events The ZBClient class extends EventEmitter. As well as invoking any callback handlers passed to the constructor, the ZBClient emits the ready and connectionError events.\nThis means that you can do things like attach one-time listeners, or write a module that contains reusable connection logic and wraps a ZBClient instance. For an example of this, see the zeebe-canaryize package.\ngRPC status jitter and connectionTolerance When the gRPC connection fails, as the gRPC channel tries to reconnect, it rapidly cycles between connected / disconnected before settling on disconnected. To avoid calling the onReady and onConnectionError callbacks rapidly in multiple succession and emitting a stream of events, the client debounces the channel status transitions, and requires the channel to be in the new state for 3 seconds before calling it.\nThe default window of three seconds is based on observation of production systems using specific proxies. You might find that you need a different window for connection tolerance, in which case you can pass in another value for connectionTolerance in the ZBClient constructor:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ connectionTolerance: 3000 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ connectionTolerance: 3000 })     "
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]