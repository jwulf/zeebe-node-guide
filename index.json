[
{
	"uri": "http://example.org/introduction/zeebe-node/",
	"title": "Zeebe Node",
	"tags": [],
	"description": "",
	"content": "The zeebe-node npm package is an open-source library for creating Node.js Zeebe client applications.\n"
},
{
	"uri": "http://example.org/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Introduction "
},
{
	"uri": "http://example.org/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Installation Adding the Zeebe Node client to your Node.js project.\n"
},
{
	"uri": "http://example.org/quickstart/",
	"title": "Quick Start",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Quick Start Get a basic Zeebe application running in next to no time.\n"
},
{
	"uri": "http://example.org/installation/install/install/",
	"title": "Install",
	"tags": [],
	"description": "",
	"content": " The Zeebe Node client is available via npm.\nAdd to an existing project  npm i zeebe-node    Create a new Node.js project  mkdir myproject cd myproject npm init -y npm i zeebe-node    "
},
{
	"uri": "http://example.org/",
	"title": "Zeebe Node.js Client Guide",
	"tags": [],
	"description": "",
	"content": " Zeebe Node.js Client Guide "
},
{
	"uri": "http://example.org/introduction/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": " Intended Audience This guide is intended for Node.js developers who want to develop Zeebe client applications in JavaScript or TypeScript.\nFamiliarity with ES6 JavaScript or the TypeScript programming language, Node.js, and a working development environment are assumed.\nConfiguring your TypeScript transpilation is out of scope. For that, consult the TypeScript documentation.\nWhat this guide covers This guide walks you through using the JavaScript client for Zeebe, giving you the practical steps to write a fully-fledged Zeebe client application using either ES6 JavaScript or TypeScript.\nIf you want to:\n Evaluate whether Zeebe is a good fit as a solution to your business problem. Build a POC using Zeebe and Node.js. Go to production with a Zeebe solution written in JavaScript / TypeScript.  You\u0026rsquo;ve come to the right place.\nZeebe Broker You will need a running Zeebe broker during development. For instructions on installing a broker for local development and testing, consult the Zeebe broker documentation.\nCode language Code samples are presented in both JavaScript (ES6) and TypeScript, in tabs:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     "
},
{
	"uri": "http://example.org/quickstart/quickstart/",
	"title": "Zeebe Node Quickstart",
	"tags": [],
	"description": "",
	"content": " Prerequisites  Node.js / npm A Zeebe broker running locally (refer to the broker documentation).  Import the Zeebe Node library Create an index.js file (or index.ts for TypeScript).\nIn there, import the Zeebe Node library:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39;  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;)     Create a ZBClient  import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     This establishes a connection to a Zeebe broker running on localhost:26500. This is the default when no arguments are passed to the constructor and no environment variables are set.\nThe connection is eager. This will throw if a broker connection cannot be established - although at this point, this program exits before the connection timeout is reached.\nQuery the broker topology The ZBClient.topology() method queries the broker topology. It returns a Promise of a broker topology object.\nOperations involving the broker are asynchronous. They involve network calls, so they return Promises that need to be awaited, or composed using Promise.then.\nHere we query the broker topology using the Promise interface:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() zbc.topology() .catch(console.error) .then(res =\u0026gt; console.log(JSON.stringify(res, null, 2)))  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() zbc.topology() .catch(console.error) .then(res =\u0026gt; console.log(JSON.stringify(res, null, 2)))     For the rest of this guide, we will mostly be using the async/await approach to Promise handling in examples.\nHere is the same code to query the broker topology, written using async/await:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { const res = await zbc.topology() console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { const res = await zbc.topology() console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     You can use either style in your code.\nOutput If the broker is running and accessible, you will see something like the following:\n{ \u0026quot;brokers\u0026quot;: [ { \u0026quot;partitions\u0026quot;: [], \u0026quot;nodeId\u0026quot;: 0, \u0026quot;host\u0026quot;: \u0026quot;172.26.0.2\u0026quot;, \u0026quot;port\u0026quot;: 26501 } ], \u0026quot;clusterSize\u0026quot;: 1, \u0026quot;partitionsCount\u0026quot;: 1, \u0026quot;replicationFactor\u0026quot;: 1 }  Note: if the broker is running in Docker, the host IP address reported by the topology command is the internal Docker network IP of the broker.\nNetwork errors and automatic retries If the broker is not started, or is not accessible to your client, you will see a stream of errors - similar to the one below - that slow down over time.\n{\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/tmp/myproject/node_modules/zeebe-node/dist/zb/ZBClient.js:382\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;14 UNAVAILABLE: failed to connect to all addresses\u0026quot;,\u0026quot;pollMode\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;taskType\u0026quot;:\u0026quot;ZBClient\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-11 22:39:32PM\u0026quot;,\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-11T12:39:32.155Z\u0026quot;} {\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/tmp/myproject/node_modules/zeebe-node/dist/zb/ZBClient.js:374\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;gRPC connection is in failed state. Attempt 5. Retrying in 5s...\u0026quot;,\u0026quot;pollMode\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;taskType\u0026quot;:\u0026quot;ZBClient\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-11 22:39:37PM\u0026quot;,\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-11T12:39:37.159Z\u0026quot;}  These are due to the Zeebe Node client\u0026rsquo;s built-in backoff-retry logic for network-related errors. The client automatically retries to establish the connection until it connects, or retries are exhausted.\nYou can disable automatic retries if you want network errors to bubble up immediately to your code, and write your own logic to handle them. See the later section on the ZBClient for more details.\nLogs The client logs to the console by default (you can inject a replacement), using a structured JSON format - ndjson. To view the log output in a human-readable format, you can use pino-pretty.\nInstall pino-pretty globally:\n npm i -g pino-pretty    Now, pipe your program\u0026rsquo;s output through pino-pretty:\n node index.js | pino-pretty    Log messages will now be formatted for your viewing pleasure:\n[2019 Nov-11 23:43:48PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/tmp/myproject/node_modules/zeebe-node/dist/zb/ZBClient.js:382\u0026quot; message: \u0026quot;14 UNAVAILABLE: failed to connect to all addresses\u0026quot; pollMode: \u0026quot;\u0026quot; taskType: \u0026quot;ZBClient\u0026quot; [2019 Nov-11 23:43:53PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/tmp/myproject/node_modules/zeebe-node/dist/zb/ZBClient.js:374\u0026quot; message: \u0026quot;gRPC connection is in failed state. Attempt 10. Retrying in 5s...\u0026quot; pollMode: \u0026quot;\u0026quot; taskType: \u0026quot;ZBClient\u0026quot;  Deploy a Workflow The next task is to deploy a workflow to the broker.\nThe method ZBClient.deployWorkflow() takes a path to a .bpmn file, and deploys that BPMN file to the broker, returning a Promise of a broker response.\nHere is the sample workflow that we will be using:\nIt has a single task in it.\nDownload the sample bpmn file from this bpmn-sample GitHub repository.\nIf you are using JavaScript or transpiling TypeScript in-place (outputting the .js files next to the .ts source files), then put the .bpmn file in the same directory as your index file. You will need to use the path ./sample.bpmn.\nIf you are transpiling your TypeScript from a source directory to an output directory, then put the .bpmn file in the directory above your source directory. You will need to use the path ../sample.bpmn.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { const res = await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { const res = await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     Output You will see output similar to the following:\n{ \u0026quot;workflows\u0026quot;: [ { \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;version\u0026quot;: 1, \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813685249\u0026quot;, \u0026quot;resourceName\u0026quot;: \u0026quot;sample.bpmn\u0026quot; } ], \u0026quot;key\u0026quot;: \u0026quot;2251799813685250\u0026quot; }  The workflow has been deployed to the broker, and you can now start an instance of the workflow, using its bpmnProcessId - \u0026ldquo;sample-process\u0026rdquo; (this is defined in the .bpmn file).\nCreate a Workflow Instance The method ZBClient.createWorkflowInstance() creates (and starts) a workflow instance. It takes a BPMN Process Id and an initial variables object, and returns a Promise of a create workflow instance response.\nThere is no problem leaving the deployWorkflow command in the code - the broker will not update the deployment if the file has not changed since the last deployment, and it ensures that the workflow definition we are about to start an instance of is deployed.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstance(\u0026#39;sample-process\u0026#39;, {}); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstance(\u0026#39;sample-process\u0026#39;, {}); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     Output You will see output similar to the following:\n{ \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813685249\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;version\u0026quot;: 1, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813685252\u0026quot; }  An instance of the workflow has been started.\nCreate a Worker "
},
{
	"uri": "http://example.org/introduction/not-rest/",
	"title": "Zeebe client applications",
	"tags": [],
	"description": "",
	"content": " Zeebe is a highly-scalable, cloud-native microservices orchestration engine that uses BPMN to orchestrate microservices.\nPolling model Zeebe clients communicate with a Zeebe broker cluster through a gateway. Communication between the JavaScript client code and the gateway is over gRPC. That means that your client applications poll the gateway for available tasks. The Zeebe broker does not invoke your microservices over REST. If you come from a REST architecture background, or have an existing REST microservices architecture that you want to orchestrate, you should take the time to understand the Zeebe model as it is, before trying to figure out how to use it with RESTful services. It is definitely possible, but you need to wire it up to work.\nThink of it like this: your Zeebe worker, written in JavaScript, subscribes to a task type on the gateway. It then runs in a loop, polling the gateway for that task type. When jobs of that task type are available, the gateway returns them to the worker. If you have an existing RESTful microservice that you want to invoke for jobs of that task type, then your Zeebe worker can invoke it. And that\u0026rsquo;s how you wire up Zeebe with existing RESTful microservices.\nYou could do something like create a worker that subscribes to many task types and has a map for the task type to the REST endpoint that should be invoked for it.\nThe important thing to understand is that workers subscribe to a task type, and poll for jobs of that task type. So it is a pull model, rather than the push model of REST, where the broker would invoke a REST service.\nThe pull model means that you can scale the workers without configuring routing or load-balancing, as you would need to do if it were a push model.\nIf you are writing a system from scratch, then you can put your business logic directly in a polling worker - or you can put the business logic in a REST endpoint if you need to reuse it from other places, and wrap the REST call in a Zeebe worker.\n"
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]