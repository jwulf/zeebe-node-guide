[
{
	"uri": "http://example.org/introduction/zeebe-node/",
	"title": "Zeebe Node",
	"tags": [],
	"description": "",
	"content": "The zeebe-node npm package is an open-source library for creating Node.js Zeebe client applications.\nIt was developed internally at an early-adopter of Zeebe - Credit Sense in Australia - by Josh Wulf. Credit Sense contributed it to the community by making it open-source, and it has gone on to become a popular way to write Zeebe applications.\nIt is written in TypeScript, and can be used with TypeScript or JavaScript.\n"
},
{
	"uri": "http://example.org/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Introduction "
},
{
	"uri": "http://example.org/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Installation Adding the Zeebe Node client to your Node.js project.\n"
},
{
	"uri": "http://example.org/zbclient/overview/",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": "ZBClient Overview The ZBClient is the main class in the Node client. It is used to connect to the broker, deploy workflow definitions, start workflow instances, publish messages, and to create workers that will service Zeebe tasks.\n"
},
{
	"uri": "http://example.org/quickstart/",
	"title": "Quick Start",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Quick Start Get a basic Zeebe application running in next to no time.\n"
},
{
	"uri": "http://example.org/zbclient/",
	"title": "ZBClient",
	"tags": [],
	"description": "",
	"content": "Chapter 3 ZBClient The ZBClient class.\n"
},
{
	"uri": "http://example.org/zblogger/",
	"title": "ZBLogger",
	"tags": [],
	"description": "",
	"content": "Chapter 4 ZBLogger The ZBLogger class.\n"
},
{
	"uri": "http://example.org/zbclient/connection/",
	"title": "Connection",
	"tags": [],
	"description": "",
	"content": "ZBClient Connection Using the ZBClient to connect with a Zeebe broker.\n"
},
{
	"uri": "http://example.org/zbworker/",
	"title": "ZBWorker",
	"tags": [],
	"description": "",
	"content": "Chapter 5 ZBWorker The ZBWorker class.\n"
},
{
	"uri": "http://example.org/zbclient/logging/",
	"title": "Logging",
	"tags": [],
	"description": "",
	"content": "ZBClient Logging Configuring logging.\n"
},
{
	"uri": "http://example.org/zbclient/grpc/",
	"title": "gRPC Configuration",
	"tags": [],
	"description": "",
	"content": "ZBClient gRPC Configuration Configuring the ZBClient gRPC connection.\n"
},
{
	"uri": "http://example.org/deploywf/",
	"title": "Deploy Workflow Definitions",
	"tags": [],
	"description": "",
	"content": "Chapter 8 Deploy Workflow Definitions Deploying Workflow Definitions to the Broker Cluster.\n"
},
{
	"uri": "http://example.org/createwf/",
	"title": "Create (Start) a Workflow Instance",
	"tags": [],
	"description": "",
	"content": "Chapter 9 Create (Start) a Workflow Instance Creating Workflow Instances.\n"
},
{
	"uri": "http://example.org/create-worker/",
	"title": "Create a ZBWorker",
	"tags": [],
	"description": "",
	"content": "Chapter 10 Create a ZBWorker Creating and configuring a ZBWorker.\n"
},
{
	"uri": "http://example.org/publish-message/",
	"title": "Publish a Message",
	"tags": [],
	"description": "",
	"content": "Chapter 11 Publish a Message Publishing messages to the broker.\n"
},
{
	"uri": "http://example.org/typesafety/",
	"title": "Type-safe Applications",
	"tags": [],
	"description": "",
	"content": "Chapter 12 Type-safe Applications Building Type-safe applications with TypeScript and Zeebe.\n"
},
{
	"uri": "http://example.org/installation/install/install/",
	"title": "Install",
	"tags": [],
	"description": "",
	"content": "The Zeebe Node client is available via npm.\nAdd to an existing project npm i zeebe-node Create a new Node.js project mkdir myproject cd myproject npm init -y npm i zeebe-node Make it a TypeScript project npm i -g typescript tsc --init Optional: Zeebe Modeler The Zeebe Modeler is an Electron app that allows you to create, examine, and inspect BPMN files.\nYou can download a release of the Zeebe Modeler from GitHub here.\nOptional: zbctl The zbctl binary is a command-line client that you can use to send commands to a Zeebe broker cluster. It is useful for debugging and testing.\nTo install zbctl:\nnpm i -g zbctl After installation, you can run zbctl and see the available options with:\nzbctl "
},
{
	"uri": "http://example.org/",
	"title": "Zeebe Node.js Client Guide",
	"tags": [],
	"description": "",
	"content": "Zeebe Node.js Client Guide "
},
{
	"uri": "http://example.org/introduction/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Intended Audience This guide is intended for Node.js developers who want to develop Zeebe client applications in JavaScript or TypeScript.\nFamiliarity with ES6 JavaScript or the TypeScript programming language, Node.js, and a working development environment are assumed.\nConfiguring your TypeScript transpilation is out of scope. For that, consult the TypeScript documentation.\nWhat this guide covers This guide walks you through using the JavaScript client for Zeebe, giving you the practical steps to write a fully-fledged Zeebe client application using either ES6 JavaScript or TypeScript.\nIf you want to:\n Evaluate whether Zeebe is a good fit as a solution to your business problem. Build a POC using Zeebe and Node.js. Go to production with a Zeebe solution written in JavaScript / TypeScript.  You've come to the right place.\nZeebe Broker You will need a running Zeebe broker during development. For instructions on installing a broker for local development and testing, consult the Zeebe broker documentation.\nCode language Code samples are presented in both JavaScript (ES6) and TypeScript, in tabs:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     "
},
{
	"uri": "http://example.org/zbclient/grpc/grpc/",
	"title": "gRPC",
	"tags": [],
	"description": "",
	"content": "gRPC Communication between your application and the Zeebe broker gateway uses gRPC, a Remote Procedure Call framework that uses a highly efficient binary protocol that multiplexes requests over a persistent HTTP/2 connection.\ngRPC was originally developed at Google for use in their data centers, and is growing in popularity. Its main attractive features are its strong type safety and explicit interface definition through the .proto file, efficiency, and language agnosticism - an important factor in a large polyglot environment like Google, where services written in Go, Java, and C++ all need to talk to each other.\nZeebe was designed to be language agnostic, so gRPC was chosen as the protocol.\nJavaScript doesn't have the same JSON-serialization penalty that these other languages do, so most JavaScript client applications talk JSON over REST, and you may be encountering gRPC for the first time with Zeebe.\nMost of the gRPC nature of the communication with the broker is abstracted away in the Node client, and you will be interacting with idiomatic JavaScript objects.\nWhere the gRPC implementation detail leaks, in our experience, is when the transport layer fails. Using the Node client directly against the broker, this is not noticeable - but in production environments with proxies and load-balancers, you are more likely to become aware that gRPC is the medium.\nFor example: your reverse proxy in production may terminate \u0026ldquo;idle\u0026rdquo; connections at a limit that is shorter than your application's configured polling interval - in which case you will see errors in production that never show up when running directly against an unproxied broker in development.\nThe best advice we can give you is to configure your development environment as close as possible to your production environment - including any reverse proxy configuration - and surface these issues as far forward as you can.\nThe gRPC module The Node client uses the C-based grpc module. There is a pure JavaScript module that we may switch to in the future, but what this means for now is that your node_modules need to be installed in or rebuilt for your run-time environment.\nFor example: you cannot install the Node client on a Windows machine, then mount your working directory into an Ubuntu-based Docker container to run it. The grpc module will need to be rebuilt for Ubuntu in the container using:\nnpm rebuild "
},
{
	"uri": "http://example.org/zbworker/zbworker/",
	"title": "ZBWorker class",
	"tags": [],
	"description": "",
	"content": "The ZBWorker is the class used to create Zeebe Job workers. The detailed API documentation is available here.\nYour Workflow Definitions contain tasks. A task has a task type.\nWhen you create a workflow instance, the broker will create a job for a task. A job is a specific concrete instance of a task.\nAn ZBWorker subscribes to the gateway for jobs of a specific task type, and continually polls the gateway for available jobs. When there is work for the worker to do, the gateway responds to the poll with a stream of jobs, and the worker's job handler is invoked for each job.\n"
},
{
	"uri": "http://example.org/zbclient/connection/connection/",
	"title": "Connection to the Zeebe broker",
	"tags": [],
	"description": "",
	"content": "Broker Gateway address The ZBClient class establishes a connection to a Zeebe broker cluster, and is used to send commands to the broker.\nConceptually, the ZBClient \u0026ldquo;talks to a broker\u0026rdquo;. In practice, the ZBClient talks to a gateway, which handles routing and load-balancing in the broker cluster. This means that you provide a gateway address to the ZBClient. In a development setup, you may have a single broker node with the embedded gateway enabled. In this case you can use the simplest constructor:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     In the absence of any other arguments or environment variables, the ZBClient will communicate with a gateway at 127.0.0.1 on port 26500.\nYou can explicitly provide an address to the constructor if you want. The following examples are functionally equivalent:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // Use default host and port const zbc = new ZBClient() // Use default port const zbc1 = new ZBClient(\u0026#39;127.0.0.1\u0026#39;) const zbc2 = new ZBClient(\u0026#39;localhost\u0026#39;) // Use explicit host and port const zbc1 = new ZBClient(\u0026#39;127.0.0.1:26500\u0026#39;) const zbc3 = new ZBClient(\u0026#39;localhost:26500\u0026#39;) // Use configuration object const zbc4 = new ZBClient({ hostname: \u0026#39;localhost\u0026#39;, port: 26500 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // Use default host and port const zbc = new ZBClient() // Use default port const zbc1 = new ZBClient(\u0026#39;127.0.0.1\u0026#39;) const zbc2 = new ZBClient(\u0026#39;localhost\u0026#39;) // Use explicit host and port const zbc1 = new ZBClient(\u0026#39;127.0.0.1:26500\u0026#39;) const zbc3 = new ZBClient(\u0026#39;localhost:26500\u0026#39;) // Use configuration object const zbc4 = new ZBClient({ hostname: \u0026#39;localhost\u0026#39;, port: 26500 })     Environmentalizing the connection The ZBClient constructor examines the environment for the variable ZEEBE_ADDRESS.\nFor example, given an index.js|ts file like this:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     You can run against a local broker simply with:\nnode index.js And run the same code against a remote server running on port 80 on zeebe.test.mydomain.com with:\nZEEBE_ADDRESS=zeebe.test.mydomain.com:80 node index.js "
},
{
	"uri": "http://example.org/zbclient/connection/tls/",
	"title": "TLS",
	"tags": [],
	"description": "",
	"content": "Connect to a broker with TLS You can secure communication between your client applications and the Zeebe broker cluster using TLS (Transport Layer Security). This needs to be enabled in the broker, or in an reverse proxy, to use.\nBy default, the broker does not secure the client connections with TLS, and the Node client does not use TLS for the connection.\nTo enable TLS with the Node client and connect to a broker secured with TLS, set the option useTLS to true:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // With the default, or a gateway address from the environment const zbc = new ZBClient({ useTLS: true }) // With a gateway address provided in the code const zbc = new ZBClient(gatewayAddress, { useTLS: true })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // With the default, or a gateway address from the environment const zbc = new ZBClient({ useTLS: true }) // With a gateway address provided in the code const zbc = new ZBClient(gatewayAddress, { useTLS: true })     Environmentalizing TLS To enable TLS with the Node client and connect to a broker secured with TLS, set the environment variable ZEEBE_SECURE_CONNECTION:\nZEEBE_SECURE_CONNECTION=true "
},
{
	"uri": "http://example.org/introduction/not-rest/",
	"title": "Zeebe client applications",
	"tags": [],
	"description": "",
	"content": "Zeebe is a highly-scalable, cloud-native microservices orchestration engine that uses BPMN to orchestrate microservices.\nPolling model Zeebe clients communicate with a Zeebe broker cluster through a gateway. Communication between the JavaScript client code and the gateway is over gRPC. That means that your client applications poll the gateway for available tasks. The Zeebe broker does not invoke your microservices over REST. If you come from a REST architecture background, or have an existing REST microservices architecture that you want to orchestrate, you should take the time to understand the Zeebe model as it is, before trying to figure out how to use it with RESTful services. It is definitely possible, but you need to wire it up to work.\nThink of it like this: your Zeebe worker, written in JavaScript, subscribes to a task type on the gateway. It then runs in a loop, polling the gateway for that task type. When jobs of that task type are available, the gateway returns them to the worker. If you have an existing RESTful microservice that you want to invoke for jobs of that task type, then your Zeebe worker can invoke it. And that's how you wire up Zeebe with existing RESTful microservices.\nYou could do something like create a worker that subscribes to many task types and has a map for the task type to the REST endpoint that should be invoked for it.\nThe important thing to understand is that workers subscribe to a task type, and poll for jobs of that task type. So it is a pull model, rather than the push model of REST, where the broker would invoke a REST service.\nThe pull model means that you can scale the workers without configuring routing or load-balancing, as you would need to do if it were a push model.\nIf you are writing a system from scratch, then you can put your business logic directly in a polling worker - or you can put the business logic in a REST endpoint if you need to reuse it from other places, and wrap the REST call in a Zeebe worker.\n"
},
{
	"uri": "http://example.org/quickstart/quickstart/",
	"title": "Zeebe Node Quickstart",
	"tags": [],
	"description": "",
	"content": "What you will do in this Quickstart In this Quickstart you will establish a connection to a Zeebe broker cluster, deploy a workflow definition, create instances of that workflow, create a worker to service a task in the workflow, update the workflow variables via a worker, and await a workflow's outcome.\nThis workflow will get the current weather in London, UK, and output a recommendation to take an umbrella out with you or leave your umbrella at home.\nPrerequisites  Node.js / npm A Zeebe broker  Start a Zeebe broker Local broker The easiest way to start a broker locally is to use Docker:\ndocker run -it -p 26500:26500 camunda/zeebe For other ways to start a local Zeebe broker, refer to the broker documentation.\nCamunda Cloud If you have a Camunda Cloud account, you can run this entire Quickstart against Camunda Cloud.\nIf you want to do that, you need to set the appropriate environment variables for your Camunda Cloud cluster. See this section for details.\nImport the Zeebe Node library Create an index.js file (or index.ts for TypeScript).\nEdit the file, and import the Zeebe Node library:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39;   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;)     Create a ZBClient  import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     This establishes a connection to a Zeebe broker running on localhost:26500 by default when no arguments are passed to the constructor, and no environment variables are set.\nIf you set environment variables to connect to Camunda Cloud, then it will connect to your Camunda Cloud cluster.\nThe connection is eager. This will throw if a broker connection cannot be established - although at this point, this program exits before the connection timeout is reached.\nQuery the broker topology The ZBClient.topology() method queries the broker topology. It returns a Promise of a broker topology object.\nOperations involving the broker are asynchronous. They involve network calls, so they return Promises that need to be awaited, or composed using Promise.then.\nHere we query the broker topology using the Promise interface:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() zbc.topology() .catch(console.error) .then(res =\u0026gt; console.log(JSON.stringify(res, null, 2)))   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() zbc.topology() .catch(console.error) .then(res =\u0026gt; console.log(JSON.stringify(res, null, 2)))     For the rest of this guide, we will mostly be using the async/await approach to Promise handling in examples.\nHere is the same code to query the broker topology, written using async/await syntax:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { const res = await zbc.topology() console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { const res = await zbc.topology() console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     You can use either style in your code.\nOutput: Query the broker topology If the broker is running and accessible, you will see something like the following:\n{ \u0026quot;brokers\u0026quot;: [ { \u0026quot;partitions\u0026quot;: [ { \u0026quot;partitionId\u0026quot;: 1, \u0026quot;role\u0026quot;: \u0026quot;LEADER\u0026quot; } ], \u0026quot;nodeId\u0026quot;: 0, \u0026quot;host\u0026quot;: \u0026quot;172.24.0.2\u0026quot;, \u0026quot;port\u0026quot;: 26501 } ], \u0026quot;clusterSize\u0026quot;: 1, \u0026quot;partitionsCount\u0026quot;: 1, \u0026quot;replicationFactor\u0026quot;: 1 } Note: if the broker is running in Docker, the host IP address reported by the topology command is the internal Docker network IP of the broker.\nNetwork errors and automatic retries If the broker is not started, or is not accessible to your client, you will see a stream of errors - similar to the one below - that slow down over time.\n{\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-21T13:52:00.961Z\u0026quot;,\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:433\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;[topology]: Attempt 5 (max: 50).\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-21 23:52:00PM\u0026quot;,\u0026quot;pollInterval\u0026quot;:30000,\u0026quot;namespace\u0026quot;:\u0026quot;ZBClient\u0026quot;} {\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-21T13:52:00.962Z\u0026quot;,\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:441\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;[topology]: 14 UNAVAILABLE: failed to connect to all addresses\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-21 23:52:00PM\u0026quot;,\u0026quot;pollInterval\u0026quot;:30000,\u0026quot;namespace\u0026quot;:\u0026quot;ZBClient\u0026quot;} These are due to the Zeebe Node client's built-in backoff-retry logic for network-related errors. The client automatically retries to establish the connection until it connects, or retries are exhausted.\nYou can disable automatic retries if you want network errors to bubble up immediately to your code, and write your own logic to handle them. See the gRPC Configurationchapter for more details.\nLogs The client logs to the console by default (you can inject a replacement), using a structured JSON format - ndjson. To view the log output in a human-readable format, you can use pino-pretty.\nInstall pino-pretty globally:\n npm i -g pino-pretty     Now, pipe your program's output through pino-pretty:\n node index.js | pino-pretty     Log messages will now be formatted for your viewing pleasure:\n[2019 Nov-21 23:52:54PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:433\u0026quot; message: \u0026quot;[topology]: Attempt 5 (max: 50).\u0026quot; pollInterval: 30000 namespace: \u0026quot;ZBClient\u0026quot; [2019 Nov-21 23:52:54PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:441\u0026quot; message: \u0026quot;[topology]: 14 UNAVAILABLE: failed to connect to all addresses\u0026quot; pollInterval: 30000 namespace: \u0026quot;ZBClient\u0026quot; Deploy a Workflow Definition The next task is to deploy a workflow definition to the broker.\nThe method ZBClient.deployWorkflow() takes a path to a .bpmn file, and deploys that BPMN file to the broker, returning a Promise of a broker response - a DeployWorkflowResponse.\nHere is the sample workflow definition that we will be using:\nIt has three tasks in it.\nDownload the sample bpmn file from this bpmn-sample GitHub repository.\nIf you are using JavaScript or transpiling TypeScript in-place (outputting the .js files next to the .ts source files), then put the .bpmn file in the same directory as your index file. You will need to use the path ./sample.bpmn.\nIf you are transpiling your TypeScript from a source directory to an output directory, then put the .bpmn file in the directory above your source directory. You will need to use the path ../sample.bpmn.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { const res = await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { const res = await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     Output: Deploy a Workflow Definition You will see output similar to the following:\n{ \u0026quot;workflows\u0026quot;: [ { \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;weather-report\u0026quot;, \u0026quot;version\u0026quot;: 1, \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813685249\u0026quot;, \u0026quot;resourceName\u0026quot;: \u0026quot;sample.bpmn\u0026quot; } ], \u0026quot;key\u0026quot;: \u0026quot;2251799813685250\u0026quot; } The workflow has been deployed to the broker, and you can now start an instance of the workflow, using its bpmnProcessId - \u0026ldquo;weather-report\u0026rdquo; (this is defined in the .bpmn file).\nCreate a Workflow Instance The method ZBClient.createWorkflowInstance() creates (and starts) a workflow instance. It takes a BPMN Process Id and an initial variables object, and returns a Promise of a CreateWorkflowInstance response.\nThere is no problem leaving the deployWorkflow command in the code - the broker will not update the deployment if the file has not changed since the last deployment, and it ensures that the workflow definition we are about to start an instance of is deployed.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstance(\u0026#39;weather-report\u0026#39;, { city: \u0026#34;London,uk\u0026#34; }); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstance(\u0026#39;weather-report\u0026#39;, { city: \u0026#34;London,uk\u0026#34; }); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     Output: Create a Workflow Instance You will see output similar to the following:\n{ \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813685249\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;weather-report\u0026quot;, \u0026quot;version\u0026quot;: 1, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813685252\u0026quot; } An instance of the workflow has been started.\nCreate a Worker A worker is a process that subscribes to a task type on the broker, polling for available jobs of that task type. When jobs of that task type are available, the broker streams them to the worker in response to its polling request. The workflow's job handler is invoked for each available job.\nThe method ZBClient.createWorker creates a new worker. It takes an optional worker id for tracing, a task type, and a job handler callback function. If the worker id is null, the library will assign a UUID.\nA Note on the API Key We will be making a REST call to the OpenWeatherMap API to get the current weather. The API key in the example is my personal API key, and it is rate-limited to 60 calls/minute. Please don't use it in a load or through-put test. If you find that it doesn't work, you can grab your own API key for free from OpenWeatherMap.\nInstall Axios Install the axios library to your project:\nnpm i axios Create a new file named workers.js (workers.ts for TypeScript).\nWe will create three workers: one to get the current weather report, and pass it back into the workflow, along with a weather_code to match the table of Weather Conditions from OpenWeatherMap; and one each for the decision branches.\nThe weather_code will be used by the decision gate in the BPMN to determine the recommendation, which will be added to the broker variables by another worker. Of course we could do the recommendation in a single worker, but three things to note:\n This is a demonstration that shows the interaction of a number of features. Your business logic is materialised in the BPMN and can be viewed and understood by various stakeholders in the business. Refactoring the business process and changing the system behavior is possible by modifying the BPMN (you could swap out a recommender for an IOT worker that fetches your umbrella, for example, or create a new behavior for snow).  Edit the content like this:\n import { ZBClient } from \u0026#34;zeebe-node\u0026#34; import axios from axios const zbc = new ZBClient() const API_KEY = \u0026#39;f504fb70e7c6e76703f0a88df83cdd59\u0026#39; zbc.createWorker(null, \u0026#34;get-weather-report\u0026#34;, (job, complete) =\u0026gt; { console.log(JSON.stringify(job, null, 2)) const city = job.variables.city try { const res = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${city}\u0026amp;appid=${API_KEY}`) const weather = res.data.weather[0] const weather_code = weather.id.toString[0] + \u0026#34;xx\u0026#34; complete.success({ weather_code }) } catch (e) { console.error(\u0026#34;Something went wrong!\u0026#34;) console.error(e) complete.fail(e.message) } }); zbc.createWorker(null, \u0026#34;take-umbrella\u0026#34;, (_, complete) =\u0026gt; { complete.success({ recommendation: \u0026#34;Take an umbrella!\u0026#34; }) }) zbc.createWorker(null, \u0026#34;leave-umbrella\u0026#34;, (_, complete) =\u0026gt; { complete.success({ recommendation: \u0026#34;Leave the umbrella at home!\u0026#34; }) })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const axios = require(\u0026#39;axios\u0026#39;) const zbc = new ZBClient() const API_KEY = \u0026#39;f504fb70e7c6e76703f0a88df83cdd59\u0026#39; zbc.createWorker(null, \u0026#34;get-weather-report\u0026#34;, (job, complete) =\u0026gt; { console.log(JSON.stringify(job, null, 2)) const city = job.variables.city try { const res = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${city}\u0026amp;appid=${API_KEY}`) const weather = res.data.weather[0] const weather_code = weather.id.toString[0] + \u0026#34;xx\u0026#34; complete.success({ weather_code }) } catch (e) { console.error(\u0026#34;Something went wrong!\u0026#34;) console.error(e) complete.fail(e.message) } }); zbc.createWorker(null, \u0026#34;take-umbrella\u0026#34;, (_, complete) =\u0026gt; { complete.success({ recommendation: \u0026#34;Take an umbrella!\u0026#34; }) }) zbc.createWorker(null, \u0026#34;leave-umbrella\u0026#34;, (_, complete) =\u0026gt; { complete.success({ recommendation: \u0026#34;Leave the umbrella at home!\u0026#34; }) })     When you run this, the first worker polls the broker for jobs of type \u0026lsquo;get-weather-report\u0026rsquo; and gets the job from the workflow instance you created in a previous step. It prints out the job object it receives from the broker so you can see what that looks like, then it grabs the current weather report from a REST API, and adds a workflow variable weather_code with the code for the recommendation to be made.\nThe broker then examines the variable to route the token in the workflow. One of the other workers then receives the job, and adds its recommendation to the workflow variables.\nOutput: Create a Worker You will see output similar to the following:\n{ \u0026quot;key\u0026quot;: \u0026quot;2251799813686445\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;get-weather-report\u0026quot;, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813686440\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;weather-report\u0026quot;, \u0026quot;workflowDefinitionVersion\u0026quot;: 1, \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813686430\u0026quot;, \u0026quot;elementId\u0026quot;: \u0026quot;ServiceTask_1aj1tsb\u0026quot;, \u0026quot;elementInstanceKey\u0026quot;: \u0026quot;2251799813686444\u0026quot;, \u0026quot;customHeaders\u0026quot;: {}, \u0026quot;worker\u0026quot;: \u0026quot;559fe180-c860-44ba-a6c5-8d32d6b9e026\u0026quot;, \u0026quot;retries\u0026quot;: 3, \u0026quot;deadline\u0026quot;: \u0026quot;1574076501831\u0026quot;, \u0026quot;variables\u0026quot;: { \u0026quot;city\u0026quot;: \u0026quot;London,uk\u0026quot; } } This is the job object that is received by the first worker. Your workers can perform any side-effects and any calculations they need to, and post any updates to the job variables.\nThe workflow ran to completion, but only the first worker has an I/O side-effect, so you won't see any further feedback.\nYour workers are sitting there polling for more work. Hit Ctrl-C to kill the worker when you are ready to move on.\n\u0026ldquo;But where do I see the recommendation?\u0026rdquo; I hear you ask. If you ran this against a local broker with Operate, or on Camunda Cloud, you could inspect the workflow in the Completed Instances filter in the Operate UI. You could log it out in the recommendation workers - but that's hardly useful in a real system. You probably want to get the outcome back to the requestor somehow. The simplest way to do this is to await the workflow outcome when starting it.\nGet the output of a workflow This next step requires 0.22.0-alpha1 or later of the broker, and v0.22.0-alpha.1 or later of the Node client. We are going to use the createWorkflowInstanceWithResult() method of the client to await the outcome of the workflow. This method was introduced with that version and does not work in earlier versions.\nStart the worker now, and modify index.js|ts to be this:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstanceWithResult(\u0026#39;weather-report\u0026#39;, { city: \u0026#34;London,uk\u0026#34; }); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstanceWithResult(\u0026#39;weather-report\u0026#39;, { city: \u0026#34;London,uk\u0026#34; }); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     Output: Get the output of a workflow In your process that creates and awaits the workflow, you will see something similar to the following, depending on the current weather in London:\n{ \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813686430\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;weather-report\u0026quot;, \u0026quot;version\u0026quot;: 1, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813686665\u0026quot;, \u0026quot;variables\u0026quot;: { \u0026quot;city\u0026quot;: \u0026quot;London,uk\u0026quot;, \u0026quot;weather_code\u0026quot;: \u0026quot;2xx\u0026quot;, \u0026quot;recommendation\u0026quot;: \u0026quot;Leave the umbrella at home!\u0026quot; } } The completed workflow variables are now output.\nSummary In this Quickstart you deployed a workflow definition, created instances of that workflow, created workers to service the single task in the workflow, updated job variables, and awaited a workflow's outcome.\nThis is 80% of what you'll be doing with the Zeebe Node client in your application.\nThe rest of this guide covers each of these aspects in more depth, and covers the other available methods\n"
},
{
	"uri": "http://example.org/zbclient/connection/basic-auth/",
	"title": "Basic Auth",
	"tags": [],
	"description": "",
	"content": "Connect to a broker with Basic Auth You can secure a Zeebe cluster with Basic Auth using an reverse proxy. In this case you can use a username / password pair as effectively an API key for your client applications.\nBasic Auth without TLS To enable Basic Auth without TLS:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ basicAuth: { username: \u0026#39;basicAuth-username\u0026#39;, password: \u0026#39;basicAuth-password\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 80 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ basicAuth: { username: \u0026#39;basicAuth-username\u0026#39;, password: \u0026#39;basicAuth-password\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 80 })     Basic Auth with TLS To enable Basic Auth with TLS:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ basicAuth: { username: \u0026#39;basicAuth-username\u0026#39;, password: \u0026#39;basicAuth-password\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443, useTLS: true })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ basicAuth: { username: \u0026#39;basicAuth-username\u0026#39;, password: \u0026#39;basicAuth-password\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443, useTLS: true })     Environmentalizing Basic Auth configuration The following environment variables control Basic Auth configuration:\nZEEBE_BASIC_AUTH_USERNAME ZEEBE_BASIC_AUTH_PASSWORD To enable TLS on the connection:\nZEEBE_SECURE_CONNECTION=true "
},
{
	"uri": "http://example.org/createwf/createwf/",
	"title": "Create a Workflow Instance",
	"tags": [],
	"description": "",
	"content": "Workflow Instances A Workflow instance (also known as a process instance) is a specific instance of a process. Each instance has its own variables and its own lifecycle.\nCreate a Workflow Instance Creating and starting a workflow is a single operation:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import type { CreateWorkflowInstanceResponse } from \u0026#39;zeebe-node\u0026#39; // TS 3.8+  const zbc = new ZBClient() async function startWorkflowInstance(bpmnProcessId: string, initialVariables = {}): Promise\u0026lt;ZB.CreateWorkflowInstanceResponse | undefined\u0026gt; { try { const res = await zbc.createWorkflowInstanceWithResult(bpmnProcessId, { sourceValue: 5, }) console.log(`Started an instance of the ${bpmnProcessId}workflow, with instance id ${res.workflowInstanceKey}`) return res } catch (e) { console.log(`There was an error starting an instance of ${bpmnProcessId}!`) console.log(e) return undefined } } startWorkflowInstance(\u0026#39;my-workflow\u0026#39;, { userid: 34, name: \u0026#39;Jane Doe\u0026#39; }).then(console.log)   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function startWorkflowInstance(bpmnProcessId, initialVariables = {}) { try { const res = await zbc.createWorkflowInstance(filepaths, initialVariables) console.log(`Started an instance of the ${bpmnProcessId}workflow, with instance id ${res.workflowInstanceKey}`) return res } catch (e) { console.log(`There was an error starting an instance of ${bpmnProcessId}!`) console.log(e) return undefined } } startWorkflowInstance(\u0026#39;my-workflow\u0026#39;, { userid: 34, name: \u0026#39;Jane Doe\u0026#39; }).then(console.log)     Create a workflow instance and await its outcome A common requirement in an application is to react to or communicate the final state of a workflow instance. For short running workflows, Zeebe provides a command that returns a Promise of the workflow outcome: createWorkflowInstanceWithResult.\n import { ZBClient, CreateWorkflowInstanceWithResultResponse } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function processUser(user: UserRecord) { try { const res = await zbc.createWorkflowInstanceWithResult(\u0026#39;user-something-process\u0026#39;, user) return res } catch (e) { console.log(`There was an error running the \u0026#39;user-something-process\u0026#39;!`) throw e } } processUser({ userid: 34, name: \u0026#39;Jane Doe\u0026#39; }) .then(({variables}) =\u0026gt; console.log(`User ${variables.name}approved: `, variables.approved)) .catch(e =\u0026gt; console.log(e))   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function processUser(user) { try { const res = await zbc.createWorkflowInstanceWithResult(\u0026#39;user-something-process\u0026#39;, user) return res } catch (e) { console.log(`There was an error running the \u0026#39;user-something-process\u0026#39;!`) throw e } } processUser({ userid: 34, name: \u0026#39;Jane Doe\u0026#39; }) .then(({variables}) =\u0026gt; console.log(`User ${variables.name}approved: `, variables.approved)) .catch(e =\u0026gt; console.log(e))     IMPORTANT! createWorkflowInstanceWithResult has a timeout Be aware that if your createWorkflowInstanceWithResult request times out, or the connection with the broker is lost during this operation, you will not receive the outcome, and will you not receive the process instance id to search for the outcome in an exporter like ElasticSearch. You can mitigate against this by specifying a request timeout, and also by appending a key to allow you to find it in the exporter data, if you need to.\nThe default timeout for this operation is the Zeebe gateway request timeout, which - if you didn't modify the setting in zeebe.cfg.toml on the broker - is 15 seconds. If your workflow instance takes longer than the timeout to complete, the operation will throw.\nYou can mitigate this by raising the request timeout on the broker, or specifying a custom request timeout for this call. See below for an example of a call that specifies a request timeout, and a user-assigned key (in the variables) to search for the instance in the exporter.\n import { ZBClient, CreateWorkflowInstanceWithResultResponse } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function processUser(user: UserRecord) { try { const res = await zbc.createWorkflowInstanceWithResult({ processId: \u0026#39;user-something-process\u0026#39;, variables: user, requestTimeout: 2 * 60 * 1000 // 2m  }) return res } catch (e) { console.log(`There was an error running the \u0026#39;user-something-process\u0026#39;!`) throw e } } processUser({ userid: 34, name: \u0026#39;Jane Doe\u0026#39;, myProcessUid: \u0026#39;to-find-instance-in-exporter\u0026#39; }) .then(({variables}) =\u0026gt; console.log(`User ${variables.name}approved: `, variables.approved)) .catch(e =\u0026gt; console.log(e))   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function processUser(user) { try { const res = await zbc.createWorkflowInstanceWithResult({ processId: \u0026#39;user-something-process\u0026#39;, variables: user, requestTimeout: 2 * 60 * 1000 // 2m  }) return res } catch (e) { console.log(`There was an error running the \u0026#39;user-something-process\u0026#39;!`) throw e } } processUser({ userid: 34, name: \u0026#39;Jane Doe\u0026#39;, myProcessUid: \u0026#39;to-find-instance-in-exporter\u0026#39; }) .then(({variables}) =\u0026gt; console.log(`User ${variables.name}approved: `, variables.approved)) .catch(e =\u0026gt; console.log(e))     You may not care about losing the information about the identity and outcome of a workflow instance, and your system may be resilient to this failure mode. It may not be - the outcome may be critical, or the process expensive to run, or your workflow may be long-running and you cannot rely on your application maintaining state for the duration of the workflow instance (maybe your application gets redeployed, in which case all of these operations in-flight disappear). In these cases you should investigate another design solution, such as the Outcome Worker pattern (see this blog post).\n"
},
{
	"uri": "http://example.org/deploywf/deploy/",
	"title": "Deploy Workflow Definitions",
	"tags": [],
	"description": "",
	"content": "Workflow Definitions Workflow definitions are XML files that specify a process using the BPMN (Business Process Model and Notation) schema with Zeebe extensions.\nYou can create and edit these files using the graphical Zeebe modeler.\nDeploy workflow definition files The method ZBClient.deployWorkflow can take a string or an array of strings, where each string is a file path to a BPMN file containing a workflow definition to deploy:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import path from \u0026#39;path\u0026#39; const zbc = new ZBClient() async function deployMyWorkflowDefinition(filepaths: string | string[]) { const res = await zbc.deployWorkflow(filepaths) console.log(res) return res } deployMyWorkflowDefinition( path.join( __dirname, \u0026#39;..\u0026#39;, \u0026#39;bpmn\u0026#39;, \u0026#39;my-workflow.bpmn\u0026#39; ))   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const path = require(\u0026#39;path\u0026#39;) const zbc = new ZBClient() async function deployMyWorkflowDefinition(filepaths) { const res = await zbc.deployWorkflow(filepaths) console.log(res) return res } deployMyWorkflowDefinition( path.join( __dirname, \u0026#39;..\u0026#39;, \u0026#39;bpmn\u0026#39;, \u0026#39;my-workflow.bpmn\u0026#39; ))     The deployWorkflow command returns a DeployWorkflowResponse. This has an array of WorkflowMetadata, containing information about the workflow definitions deployed.\nThe method will throw if any of the workflow definitions are malformed - in this case none are deployed. @TODO - verify\nNote on versioning: Re-deploying a workflow definition does not create a new version of that workflow definition in the broker cluster, unless the definition has been modified - in which case a new version is created.\nDeploy a workflow definition from an in-memory buffer ZBClient.deployWorkflow can also deploy a workflow definition from an in-memory buffer.\nThis is useful if, for example, you perform template processing on a workflow definition after loading it from a file, before deploying it. See here for an example of doing that with micromustache.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import { transformWfd } from \u0026#39;./my-workflow-transformer\u0026#39; import fs from \u0026#39;fs\u0026#39;; import path from \u0026#39;path\u0026#39; const zbc = new ZBClient() async function deployMyWorkflowDefinition(filepath: string) { const workflow = fs.readFileSync(filepath, \u0026#39;utf-8\u0026#39;) const xFormedWfd = transformWfd(workflow) const res = await zbc.deployWorkflow({ definition: Buffer.from(xFormedWfd), name: path.basename(filepath) }) console.log(res) return res } deployMyWorkflowDefinition( path.join( __dirname, \u0026#39;..\u0026#39;, \u0026#39;bpmn\u0026#39;, \u0026#39;my-workflow.bpmn\u0026#39; ))   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) import { transformWfd } from \u0026#39;./my-workflow-transformer\u0026#39; import fs from \u0026#39;fs\u0026#39;; const path = require(\u0026#39;path\u0026#39;) const zbc = new ZBClient() async function deployMyWorkflowDefinition(filepath: string) { const workflow = fs.readFileSync(filepath, \u0026#39;utf-8\u0026#39;) const xFormedWfd = transformWfd(workflow) const res = await zbc.deployWorkflow({ definition: Buffer.from(xFormedWfd), name: path.basename(filepath) }) console.log(res) return res } deployMyWorkflowDefinition( path.join( __dirname, \u0026#39;..\u0026#39;, \u0026#39;bpmn\u0026#39;, \u0026#39;my-workflow.bpmn\u0026#39; ))     "
},
{
	"uri": "http://example.org/zbclient/logging/logging/",
	"title": "Logging",
	"tags": [],
	"description": "",
	"content": "Log format The Node client logs its messages using a structured JSON format - ndjson. These messages are designed to be easily parsed by scripts.\nThe messages are output to the console by default, and look like this:\n{\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-21T13:52:00.961Z\u0026quot;,\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:433\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;[topology]: Attempt 5 (max: 50).\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-21 23:52:00PM\u0026quot;,\u0026quot;pollInterval\u0026quot;:30000,\u0026quot;namespace\u0026quot;:\u0026quot;ZBClient\u0026quot;} {\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-21T13:52:00.962Z\u0026quot;,\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:441\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;[topology]: 14 UNAVAILABLE: failed to connect to all addresses\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-21 23:52:00PM\u0026quot;,\u0026quot;pollInterval\u0026quot;:30000,\u0026quot;namespace\u0026quot;:\u0026quot;ZBClient\u0026quot;} To view log messages in a human-readable format, you can pipe your program's output through pino-pretty. This results in output like this:\n[2019 Nov-21 23:52:54PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:433\u0026quot; message: \u0026quot;[topology]: Attempt 5 (max: 50).\u0026quot; pollInterval: 30000 namespace: \u0026quot;ZBClient\u0026quot; [2019 Nov-21 23:52:54PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/Camunda/zeebe-client-node-js/src/zb/ZBClient.ts:441\u0026quot; message: \u0026quot;[topology]: 14 UNAVAILABLE: failed to connect to all addresses\u0026quot; pollInterval: 30000 namespace: \u0026quot;ZBClient\u0026quot; Log message levels There are three levels of log messages:\n 20 - DEBUG 30 - INFO 50 - ERROR  Set the logging level By default, the client logs at INFO level.\nSet the log level of the ZBClient to one of the log levels - DEBUG, INFO, ERROR; or to NONE to suppress all logging.\nYou can set the logging level of the ZBClient via the ZBClient constructor:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // Suppress all log messages except errors const zbc = new ZBClient({ loglevel: \u0026#39;ERROR\u0026#39; })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // Suppress all log messages except errors const zbc = new ZBClient({ loglevel: \u0026#39;ERROR\u0026#39; })     And via the environment:\nZEEBE_NODE_LOG_LEVEL Any environment setting will override the constructor setting. This is the only setting with this precedence.\nSet a custom log namespace By default, the ZBClient logs with namespace \u0026ldquo;ZBClient\u0026rdquo;. If you have more than one ZBClient instance in your application, you can distinguish between them by setting a custom log namespace. Pass a string or array of strings to the ZBClient constructor as the logNamespace parameter.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ logNamespace: \u0026#39;zbc\u0026#39; }) const zbc1 = new ZBClient({ logNamespace: \u0026#39;zbc1\u0026#39; })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ logNamespace: \u0026#39;zbc\u0026#39; }) const zbc1 = new ZBClient({ logNamespace: \u0026#39;zbc1\u0026#39; })     Log to a custom stdout You can redirect the log output to somewhere other than the console by passing in an object with an info method that takes a string parameter.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import { postMessage } from \u0026#39;./my-http-log-sink\u0026#39; // Use a custom log sink const zbc = new ZBClient({ loglevel: \u0026#39;ERROR\u0026#39;, stdio: { info: msg =\u0026gt; postMessage(msg) } })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const { postMessage } = require(\u0026#39;./my-http-log-sink\u0026#39;) // Use a custom log sink const zbc = new ZBClient({ loglevel: \u0026#39;ERROR\u0026#39;, stdio: { info: msg =\u0026gt; postMessage(msg) } })     For an example of a custom logger, see the implementation in the Node-RED Zeebe package.\nLogging in ZBWorker The ZBWorker inherits its log settings from the ZBClient that creates it. You can also override any of the settings in the createWorker method call.\nBy default the ZBWorker logs with the namespace \u0026ldquo;ZBWorker\u0026rdquo;. If a custom namespace has been set for the ZBClient, the ZBWorker inherits it and prepends \u0026ldquo;ZBWorker\u0026rdquo; to it. If you override this with an explicit namespace, \u0026ldquo;ZBWorker\u0026rdquo; is prepended to that.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import { jobhandler } from \u0026#39;./jobhandler\u0026#39; const zbc = new ZBClient({ logNamespace: \u0026#39;Main ZBClient\u0026#39;, }) // Logs with namespace \u0026#34;ZBWorker override-namespace\u0026#34; const worker = zbc.createWorker(null, \u0026#39;get-user\u0026#39;, jobhandler, { logNamespace: \u0026#39;override-namespace\u0026#39; })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const { jobhandler } = require(\u0026#39;./jobhandler\u0026#39;) const zbc = new ZBClient({ logNamespace: \u0026#39;Main ZBClient\u0026#39;, }) // Logs with namespace \u0026#34;ZBWorker override-namespace\u0026#34; const worker = zbc.createWorker(null, \u0026#39;get-user\u0026#39;, jobhandler, { logNamespace: \u0026#39;override-namespace\u0026#39; })     "
},
{
	"uri": "http://example.org/zbclient/connection/oauth/",
	"title": "OAuth",
	"tags": [],
	"description": "",
	"content": "Connect to a broker with OAuth You can secure a Zeebe cluster with OAuth using a proxy. In this case, the Node client can retrieve a JWT (JSON Web Token) from a token endpoint to use to authorize requests to the broker.\nIf you are using OAuth, you are probably using TLS as well, so TLS is automatically enabled when OAuth is configured. You need to explicitly disable TLS if you are using OAuth without TLS, and re-examine your life choices (I'm kidding - this is for a development POC \u0026hellip;right??).\nIn the following example, we enable OAuth:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ oAuth: { url: \u0026#39;my-oAuth-endpoint.com\u0026#39;, audience: \u0026#39;token-audience\u0026#39;, clientId: \u0026#39;oAuth-client-id\u0026#39;, clientSecret: \u0026#39;oAuth-client-secret\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ oAuth: { url: \u0026#39;my-oAuth-endpoint.com\u0026#39;, audience: \u0026#39;token-audience\u0026#39;, clientId: \u0026#39;oAuth-client-id\u0026#39;, clientSecret: \u0026#39;oAuth-client-secret\u0026#39;, }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443 })     Environmentalizing OAuth configuration The following environment variables control OAuth configuration:\nZEEBE_TOKEN_AUDIENCE ZEEBE_AUTHORIZATION_SERVER_URL ZEEBE_CLIENT_ID ZEEBE_CLIENT_SECRET OAuth JWT caching The Node client caches the JWT in-memory, and only requests a new token when the current token expires. This is important for performance, as the client doesn't need to request a token for each request. This speeds up network requests to the gateway and reduces calls to your token-issuing endpoint.\nThe Node client also caches the token on disk. This is important in development when you are restarting your application frequently, and also when running in a stateless environment like AWS Lambda.\nBy default, the JWT is cached in the directory ~/.camunda. In some environments (such as AWS Lambda) this directory is not writable. To avoid unbounded token requests, the ZBClient will throw in its constructor if it cannot write to the token cache directory.\nYou can configure a custom token cache directory in the oAuth configuration using the optional cacheDir parameter, like this:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ useTLS: true, oAuth: { url: \u0026#39;my-oAuth-endpoint.com\u0026#39;, audience: \u0026#39;token-audience\u0026#39;, clientId: \u0026#39;oAuth-client-id\u0026#39;, clientSecret: \u0026#39;oAuth-client-secret\u0026#39;, cacheDir: \u0026#39;/cache\u0026#39; }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ useTLS: true, oAuth: { url: \u0026#39;my-oAuth-endpoint.com\u0026#39;, audience: \u0026#39;token-audience\u0026#39;, clientId: \u0026#39;oAuth-client-id\u0026#39;, clientSecret: \u0026#39;oAuth-client-secret\u0026#39;, cacheDir: \u0026#39;/cache\u0026#39; }, hostname: \u0026#39;my-secure-zeebe-gateway.com\u0026#39;, port: 443 })     Environmentalizing JWT cache The following environment variable overrides the JWT cache directory:\nZEEBE_TOKEN_CACHE_DIR "
},
{
	"uri": "http://example.org/createwf/typesafe/",
	"title": "Type-safe Workflow Instances",
	"tags": [],
	"description": "",
	"content": "Both the createWorkflowInstance and createWorkflowInstanceWithResult methods of the ZBClient have parameterised types, also known as generic types. These can provide a degree of type-checking and intellisense for the variables payload while coding.\nBy default they are set to any, so you can ignore them and the variables in and out of these functions can be anything.\nBoth createWorkflowInstance and createWorkflowInstanceWithResult take in the initial variable payload. This an arbitrarily shaped object that represents something in the business domain of your application. createWorkflowInstance returns a record of the process instance that was started that is fixed in shape and known at design-time. It is defined as part of the broker API, so it is hard-coded into the library.\ncreateWorkflowInstanceWithResult, however, returns the final state of the variables in the process instance. This, obviously, is unknown to the library, and so by default it can't help you with the shape of the object.\nYou can, however, supply typing for the input variables and the final variables shape. I recommend that you design a business domain API for your workflows, and created typed interfaces for your workflow and task inputs and outputs that are shared between workers and applications that start workflow.\nThis TypeScript example makes use of Generic typing to provide intellisense and type-safety for the variables. If you don't supply any Generic types (in angle brackets \u0026lt;\u0026gt;), the type of variables will be any. That also works fine, just with less safety.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import type { CreateWorkflowInstanceWithResultResponse } from \u0026#39;zeebe-node\u0026#39; // TS 3.8+  const zbc = new ZBClient() interface UserRecord { userid: number name: string } interface UserApprovalProcessOutcome extends UserRecord { approved: boolean } async function processUser(user: UserRecord): Promise\u0026lt;CreateWorkflowInstanceWithResultResponse\u0026lt;UserApprovalProcessOutcome\u0026gt;\u0026gt; { try { const res = await zbc.createWorkflowInstanceWithResult\u0026lt;UserRecord, UserApprovalProcessOutcome\u0026gt;(\u0026#39;user-approval-process\u0026#39;, user) return res } catch (e) { console.log(`There was an error running the \u0026#39;user-approval-process\u0026#39;!`) throw e } } processUser({ userid: 34, name: \u0026#39;Jane Doe\u0026#39; }) .then(({variables}) =\u0026gt; console.log(`User ${variables.name}approved: `, variables.approved)) .catch(e =\u0026gt; console.log(e))   // If you want type-safety, you\u0026#39;ll need to use TypeScript     In the above example, the call to createWorkflowInstanceWithResult has been parameterised to \u0026ldquo;takes a variables of shape UserRecord, returns a variables of shape UserApprovalProcessOutcome\u0026rdquo;.\nYou can further bake your business domain API by extending the ZBClient with specialised overloads for concrete process ids.\nFor example, we now know that the shape of the input and output of the process with the id user-approval-process. So when this is stable, we can materialise it in one place in the application. This reduces hand-coding, duplication. and the chance of errors, and makes it easier and safer for new developers and maintainers to interact with the code.\nYou can specialise the ZBClient to materialise the input and output shape of your processes, like this:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import type { CreateWorkflowInstanceWithResultResponse } from \u0026#39;zeebe-node\u0026#39; // TS 3.8+  interface UserRecord { userid: number; name: string; } interface FinalState extends UserRecord { approved: boolean; } interface MyZBC extends ZB.ZBClient { createWorkflowInstanceWithResult(bpmnProcessId: \u0026#39;user-approval-process\u0026#39;, variables: UserRecord): Promise\u0026lt;CreateWorkflowInstanceWithResultResponse\u0026lt;FinalState\u0026gt;\u0026gt;; createWorkflowInstanceWithResult(config: { bpmnProcessId: \u0026#39;user-something-process\u0026#39;, variables: UserRecord, requestTimeout?: number, fetchVariables?: string[] }): Promise\u0026lt;CreateWorkflowInstanceWithResultResponse\u0026lt;FinalState\u0026gt;\u0026gt;; } const zbc: MyZBC = new ZB.ZBClient()   // If you want type-safety, you\u0026#39;ll need to use TypeScript     Now when we use zbc (which we cast to MyZBC) to create a workflow instance, we get this:\nThe input and output types are picked up for the process with the concrete id user-approval-process, and flow through your application code.\nYou can then reuse the business domain object interfaces to create type-safe workers.\nThere is a fair amount of manual wiring involved to bring your application to this level of type-safety. Some people begin with types, and define the structure of their data before writing an implementation. Others experiment and discover the shape of their modelled domain through experimentation (that's me!).\nEither way, the gradual typing of TypeScript and the Zeebe Node library have your back - you can introduce as much or as little typing (all the way down to none) as you want at each step.\nFuture releases of the Zeebe Node client will allow you to parameterise the ZBClient itself with your business domain objects and process ids. This will make the specialisation automatic. Stay tuned to the CHANGELOG.md!\n"
},
{
	"uri": "http://example.org/zbworker/overview/",
	"title": "Worker Overview",
	"tags": [],
	"description": "",
	"content": "This section contains conceptual background and reference material that may be overwhelming initially. Feel free to continually refer back to this section as you need to.\nThe ZBClient method createWorker creates a new ZBWorker to service jobs.\nA job is a specific, concrete instance of a task from a running workflow.\nA ZBWorker is created for a specific task type, and continuously polls the broker for jobs of that task type.\nIt does this, under the hood, by sending an ActivateJobs gRPC command to the gateway.\nIf jobs of the worker's task type are available in the cluster, the gateway streams them back to the worker. If no jobs are available, the poll is held open - it is a long poll. If jobs appear at any time during the life-time of the poll, the gateway sends them back. The worker repolls when the current poll expires, or as soon as it has capacity for more work.\nLong polling The lifetime of the worker's long poll is configurable, and you would configure this to be as long as possible, to reduce the load on the gateway (see this blog post). At the same time, you will need to make it as short as it needs to be - we've seen 10-minute long polling perform flawlessly in development environments, and anything over 60 seconds throw errors in environments where an intermediate proxy terminated \u0026ldquo;idle\u0026rdquo; connections at that time limit. By default, the client sets this to 30 seconds.\nMaximum (Concurrent) Active Jobs The maximum number of jobs that the worker can handle concurrently is configurable. By default, this is 32. Depending on the resource intensity of the actual execution of the job, you can configure the worker capacity to be more or less.\nJob Timeout When the worker requests jobs, it lets the gateway know the duration of time that the job should be allocated to the worker. During that time, the job is marked active, and will not be allocated to any other worker. By default, in the Node client this is 60 seconds. You should be aware that the task that checks for worker job timeouts on the broker runs every 30 seconds, so if you configure a job timeout of n seconds, the effective timeout will be somewhere in the range of n to (n + 29s).\nCompleting a job after the activation timeout expires The Node client does no management of the job timeout.\nIf a worker completes a job after the timeout, as long as no other worker has completed the job already, the job will be successfully completed by the gateway. If it has already been completed, the attempt to complete it will throw. This means that your worker can receive a job, and then throw when it tries to complete it because another worker (\u0026lsquo;worker 1\u0026rsquo;) previously activated it, the activation timed out and the job was streamed to worker 2, then worker 1 came through and completed it before worker 2 did.\nIf this seems a little chaotic to you, I'm not surprised!\nHere is why it works this way - imagine that your worker activates a job and specifies a 60s timeout (which gives it 60s - 89s to complete it). Now imagine that it actually takes 95s to complete the job due to computational complexity, dependent services, or anything else you want to make up.\nNow, no worker will ever be able to complete the job in time - even though any of them could\u0026hellip;eventually.\nThis way, another worker can start work on it, but the first worker can still complete it.\nSo the job activation timeout is more a statement of \u0026ldquo;how long should we wait before deciding \u0026lsquo;this worker may have died, better try another one\u0026rsquo;\u0026rdquo; than a statement of \u0026ldquo;this is how long I think this job will take\u0026quot;.\nEventual consistency and idempotency The system is eventually consistent. That's the nature of a distributed system - the broker doesn't know what is happening in the worker until it reports back.\nSince multiple workers may receive the same job (it is at-least-once), you should make sure the side-effects of your workers are idempotent - for example, upserting records instead of inserting them.\nFailing a job after the activation timeout expires Although workers can complete jobs after the activation timeout, they cannot fail them after the activation timeout has expired. This will throw.\n"
},
{
	"uri": "http://example.org/zbclient/grpc/grpc-config/",
	"title": "ZBClient gRPC retries",
	"tags": [],
	"description": "",
	"content": "Failure - part of success All ZBClient methods that involve sending a gRPC command to the broker may fail.\nIf you are using async/await that means they will throw. If you are using Promises, they will reject and take the .catch path.\nWe divide failures into two categories:\n \u0026ldquo;Business logic errors\u0026rdquo; - for example, trying to create an instance of a workflow for which no workflow definition is deployed on the broker. \u0026ldquo;Network errors\u0026rdquo; - for example, the gRPC connection to the gateway is in a failed state while the gateway is being rescheduled by Kubernetes.  Business errors will always throw / reject.\nThe Node client can automatically retry on network errors, and does this by default.\nAutomatic retry on network errors Network errors return gRPC error code 14.\nAccording to the spec:\n The service is currently unavailable. This is most likely a transient condition, which can be corrected by retrying with a backoff. Note that it is not always safe to retry non-idempotent operations.\n To help you write robust applications that continue to operate around transient network failures and recover automatically as the network recovers, the Node client is configured by default to automatically retry operations on network failures, with a back-off.\nDisable automatic retries You can configure this, or disable it entirely if you want to code some other strategy. If you need your application to page you immediately on a network error, and definitely do not try that again (or some other custom handling), pass retry: false to the ZBClient constructor:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // Don\u0026#39;t retry. I will handle all errors. const zbc = new ZBClient({ retry: false })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // Don\u0026#39;t retry. I will handle all errors. const zbc = new ZBClient({ retry: false })     Note that you can create more than one ZBClient in an application, each with its own retry configuration, and then use the retry strategy that makes sense for each operation.\nConfigure retries If you have retries enabled, you can set the maximum number of retries that are attempted before an exception is thrown, and the maximum time between retries.\nThe retry mechanism is implemented using the promise-retry module. The backoff is exponential by a factor of 2, and by default it retries 50 times, with a maximum of 5 seconds between retries.\nTo change this, pass in values for maxRetries and maxRetryTimeout to the ZBClient constructor:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // These are the default settings. const zbc = new ZBClient({ maxRetries: 50 maxRetryTimeout: 5000 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // These are the default settings. const zbc = new ZBClient({ maxRetries: 50 maxRetryTimeout: 5000 })     Broker backpressure There is a third category of response that can be handled with automated retries. The Zeebe broker has an adaptive algorithm that detects growing latency in the system due to load, and produces backpressure. When the broker detects this, it responds to commands (other than completeJob) with gRPC error code 8 - RESOURCE EXHAUSTED.\nIf retries are enabled, in this situation the Node client applies the same retry strategy that is configured for transient network failures.\n"
},
{
	"uri": "http://example.org/zblogger/zblogger/",
	"title": "ZBLogger",
	"tags": [],
	"description": "",
	"content": "The ZBLogger class is available for you to use for logging in your application.\n import { ZBLogger } from \u0026#39;zeebe-node\u0026#39; const logger = new ZBLogger({ loglevel: \u0026#39;INFO\u0026#39;, namespace: \u0026#39;my-application-context\u0026#39;, }) logger.info(\u0026#39;Starting...\u0026#39;)   const { ZBLogger } = require(\u0026#39;zeebe-node\u0026#39;) const logger = new ZBLogger({ loglevel: \u0026#39;INFO\u0026#39;, namespace: \u0026#39;my-application-context\u0026#39;, }) logger.info(\u0026#39;Starting...\u0026#39;)     "
},
{
	"uri": "http://example.org/zbclient/overview/apidoc/",
	"title": "API Documentation",
	"tags": [],
	"description": "",
	"content": "The detailed API documentation for the ZBClient class is available here.\n"
},
{
	"uri": "http://example.org/zbworker/create-worker/",
	"title": "Create a Job Worker",
	"tags": [],
	"description": "",
	"content": "To create a Job Worker, you must first create a ZBClient. The ZBClient defines the logging, connection, and retry configuration that will be inherited by any ZBWorkers that it creates.\nThis allows you to consolidate configuration, and also create various configurations for different scenarios. Refer to the section on the ZBClientfor more information on the ZBClient class.\nCreate a Job Worker Creating a job worker is simple:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() zbc.createWorker(null, \u0026#39;get-customer\u0026#39;, (job, complete) =\u0026gt; { // Job handler goes here  })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() zbc.createWorker(null, \u0026#39;get-customer\u0026#39;, (job, complete) =\u0026gt; { // Job handler goes here  })     The first parameter of createWorker is an optional string id for the worker. This id is used in logging on the broker. If you do not assign one - passing in null as the value - then the library will assign a UUID.\nThe second parameter is the task type. In your BPM diagram your tasks have a string task type. One way to think of it is that your worker subscribes to the broker for tasks of this type. In practice, the worker polls the broker with the ActivateJobs gRPC command. When jobs of this task type are available, the broker returns them as an array.\nThe third parameter is the job handler. When work is available, the job handler is invoked for each of the available jobs.\nJob handler The job handler takes three parameters - two required and one optional.\nThe first is the job (API Docs). This is an object with metadata about the job instance from the broker, including any custom headers from the task in the BPM diagram, and the current variables from the workflow instance.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() zbc.createWorker(null, \u0026#39;get-customer\u0026#39;, (job, complete) =\u0026gt; { console.log(\u0026#39;Job\u0026#39;, job) // Job handler goes here  })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() zbc.createWorker(null, \u0026#39;get-customer\u0026#39;, (job, complete) =\u0026gt; { console.log(\u0026#39;Job\u0026#39;, job) // Job handler goes here  })     The second is the complete context (API Docs). It has two methods: complete.success() and complete.failure. When your worker is finished with its work, call one of the methods to inform the broker whether the work was a success or a failure.\nIf you call complete.failure() you must pass in a string message. If retries for this job are exhausted, then the message will be visible in Operate as the reason for the incident that is raised.\nIf you call complete.success() you can pass in a JavaScript object that is serializable to JSON. This is passed to the broker, which merges it with the current workflow instance variables.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const mockData = { \u0026#34;1\u0026#34;: { name: \u0026#34;Joe Bloggs\u0026#34; } } const mockDB = { get: id =\u0026gt; mockData[id] } const zbc = new ZBClient() zbc.createWorker(null, \u0026#39;get-customer\u0026#39;, (job, complete) =\u0026gt; { const id = job.variables.customerId const customer = mockDB.get(id) return customer ? complete.success({ customerData: customer }) : complete.failure(`Customer with id ${id}not found`) })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const mockData = { \u0026#34;1\u0026#34;: { name: \u0026#34;Joe Bloggs\u0026#34; } } const mockDB = { get: id =\u0026gt; mockData[id] } const zbc = new ZBClient() zbc.createWorker(null, \u0026#39;get-customer\u0026#39;, (job, complete) =\u0026gt; { const id = job.variables.customerId const customer = mockDB.get(id) return customer ? complete.success({ customerData: customer }) : complete.failure(`Customer with id ${id}not found`) })     The third parameter is optional, and is a reference to the worker itself. This allows you to log inside the job handler using worker.log().\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const mockData = { \u0026#34;1\u0026#34;: { name: \u0026#34;Joe Bloggs\u0026#34; } } const mockDB = { get: id =\u0026gt; mockData[id] } const zbc = new ZBClient() zbc.createWorker(null, \u0026#39;get-customer\u0026#39;, (job, complete, worker) =\u0026gt; { const id = job.variables.customerId const customer = mockDB.get(id) worker.log(`Retrieved customer ${customer?.name}`) // TS 3.7+  return customer ? complete.success({ customerData: customer }) : complete.failure(`Customer with id ${id}not found`) })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const mockData = { \u0026#34;1\u0026#34;: { name: \u0026#34;Joe Bloggs\u0026#34; } } const mockDB = { get: id =\u0026gt; mockData[id] } const zbc = new ZBClient() zbc.createWorker(null, \u0026#39;get-customer\u0026#39;, (job, complete, worker) =\u0026gt; { const id = job.variables.customerId const customer = mockDB.get(id) worker.log(`Retrieved customer ${(customer || {}).name}`) return customer ? complete.success({ customerData: customer }) : complete.failure(`Customer with id ${id}not found`) })     "
},
{
	"uri": "http://example.org/zbworker/worker-options/",
	"title": "Worker Options",
	"tags": [],
	"description": "",
	"content": "The ZBClient.createWorker() method takes an optional fourth parameter - an options object.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() const handler = (job, complete) =\u0026gt; complete.success() zbc.createWorker(null, \u0026#39;get-customer\u0026#39;, handler, { debug: false, failWorkflowOnException: false, maxJobsToActivate: 32, onConnectionErrorHandler: () =\u0026gt; console.log(\u0026#39;Disconnected!\u0026#39;), timeout: 60000 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() const handler = (job, complete) =\u0026gt; complete.success() zbc.createWorker(null, \u0026#39;get-customer\u0026#39;, handler, { debug: false, failWorkflowOnException: false, maxJobsToActivate: 32, onConnectionErrorHandler: () =\u0026gt; console.log(\u0026#39;Disconnected!\u0026#39;), timeout: 60000 })     The following options can be set (API Docs):\n debug - boolean. Set to true to turn on trace debugging for this worker. It is very verbose and is meant for debugging low-level connection issues. failWorkflowOnException - boolean. The default behavior of the client is to call complete.failure() on an unhandled exception in the job handler, passing in the exception message. If failWorkflowOnException is set to true, then an unhandled exception in the worker's job handler will reduce the retry count to 0 when it calls complete.failure(). These halts the workflow and raises an incident. This is useful to cause an immediate halt for debugging purposes. fetchVariable - an array of strings. By default, all variables in the workflow instance are passed from the broker to the worker. If you set this option, then only the variables named in this option are passed to the worker. This is useful, for example, the worker is templating variables into a transactional email to send to a customer. You do not want to accidentally template sensitive variables into the email, so you can explicitly whitelist which variables to pass to the worker. maxJobsToActivate - an integer number. By default, the worker will retrieve and work on 32 jobs simultaneously, using Node's event loop. If the handler is computationally-intensive, then you may want to limit this to a smaller number. Alternatively, you may want to raise it to a higher number. onConnectionErrorHandler - you can supply a callback function to be invoked when the gRPC connection to the broker gateway fails. This can be used to alert your infrastructure monitoring. timeout - an integer number of milliseconds. By default, the worker requests sixty seconds to complete its task. If the worker does not complete the job with either success or failure in this time, the broker will release the job to another worker. If your job handler requires more than sixty seconds to complete its work, pass in a higher value.  "
},
{
	"uri": "http://example.org/zbworker/typesafety/",
	"title": "Writing Type-Safe Workers",
	"tags": [],
	"description": "",
	"content": "This section only applies if you are using TypeScript\nThe job parameter that is passed to your worker handler is, by default, partially typed.\nThe metadata from the broker is strongly typed, but the customHeaders and variables are typed as any.\nThe argument that you pass to the complete.success() function is also typed as object.\nYou can provide explicit type information for these fields to provide greater type-safety and Intellisense support in your IDE.\nExplicitly typing Job Variables and the complete function  import { ZBClient } from \u0026#39;zeebe-node\u0026#39; interface JobVariables { customerId: number } interface CompleteVariables extends JobVariables { customerData: CustomerRecord } interface CustomerRecord { name: string } const mockData: {[key: number]: CustomerRecord} = { 1: { name: \u0026#34;Joe Bloggs\u0026#34; } } const mockDB = { get: (id: number): CustomerRecord | undefined =\u0026gt; mockData[id] } const zbc = new ZBClient() zbc.createWorker\u0026lt;JobVariables, any, CompleteVariables\u0026gt;(null, \u0026#39;get-customer\u0026#39;, (job, complete, worker) =\u0026gt; { const id = job.variables.customerId const customer = mockDB.get(id) worker.log(`Retrieved customer ${customer?.name}`) // TS 3.7+  return customer ? complete.success({ customerData: customer }) : complete.failure(`Customer with id ${id}not found`) })   // Only applicable to TypeScript     Explicitly typing Custom Headers Your task instances in the BPM can specify custom headers. You can use this feature to do things like write a generic Slack messaging worker, and derive the message to send from the job variables, and the specify which channel to send it to in the task instance via a custom header:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import { sendSlackMessage } from \u0026#39;./slack\u0026#39; interface JobVariables { message: string } interface CompleteVariables { message: \u0026#39;\u0026#39; // erase message after sending } interface CustomHeaders { channel: string } const zbc = new ZBClient() zbc.createWorker\u0026lt;JobVariables, CustomHeaders, CompleteVariables\u0026gt; async (null, \u0026#39;send-slack-message\u0026#39;, (job, complete, worker) =\u0026gt; { const { message } = job.variables const { channel } = job.customHeaders worker.log(`Sending ${message}to ${channel}`) try { await sendSlackMessage({ channel, message }) return complete.success({ message: \u0026#39;\u0026#39; }) } catch (e) { worker.log(e.message) return complete.failure(e.message) } })   // Only applicable to TypeScript     Explicitly typing Task Types Task types are arbitrary strings. This can lead to hard to diagnose bugs. To aid you in catching these as far forward as possible, the Node client can generate type information from your BPMN files.\nInstall the zeebe-node package globally:\nnpm i -g zeebe-node You now have a zeebe-node command that takes a file path to a .bpmn file, and emits type information to the console.\nThis will help you to identify all the task types in your process, and also give you type safety for your task types when writing worker handlers.\nFor example:\n➜ zeebe-node src/__tests__/testdata/hello-world.bpmn  import { ZBClient } from \u0026#34;zeebe-node\u0026#34; const zbc = new ZBClient() // @TODO Update with the shape of your job variables // For better intellisense and type-safety export interface WorkflowVariables { [key: string]: any } // Autogenerated constants for hello-world.bpmn  export enum TaskType { CONSOLE_LOG = \u0026#34;console-log\u0026#34; } export enum MessageName { WAITING_FOR_A_TRAIN_THAT_NEVER_ARRIVES = \u0026#34;Waiting For A Train That Never Arrives\u0026#34; } // Worker for tasks of type \u0026#34;console-log\u0026#34; interface ConsoleLogCustomHeaders { message: string } export const ConsoleLogWorker = zbc.createWorker\u0026lt; WorkflowVariables, ConsoleLogCustomHeaders, WorkflowVariables \u0026gt;(null, TaskType.CONSOLE_LOG, (job, complete, worker) =\u0026gt; { worker.log(job) complete.success() })   // Only applicable to TypeScript     "
},
{
	"uri": "http://example.org/zbclient/connection/camunda-cloud/",
	"title": "Camunda Cloud",
	"tags": [],
	"description": "",
	"content": "Connect to Camunda Cloud Camunda Cloud provides a fully managed Zeebe service with TLS and OAuth.\nThe Zeebe Node client provides a convenience that handles the TLS and some of the OAuth configuration for Camunda Cloud.\nTo use with Camunda Cloud, set these values in code. Note that cacheDir is optional, and should be used when the directory ~/.camunda is not writable in your runtime environment, to set a custom token cache directory (see the section on OAuth JWT caching).\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; // cacheDir is optional - see OAuth JWT caching const zbc = new ZBClient({ camundaCloud: { clientId: \u0026#39;yStuGvJ6a1RQhy8DQpeXJ80yEpar3pXh\u0026#39;, clientSecret: \u0026#39;WZahIGHjyj0-oQ7DZ_aH2wwNuZt5O8Sq0ZJTz0OaxfO7D6jaDBZxM_Q-BHRsiGO_\u0026#39;, clusterId: \u0026#39;103ca930-6da6-4df7-aa97-941eb1f85040\u0026#39;, cacheDir: \u0026#39;./tokens\u0026#39; } })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) // cacheDir is optional - see OAuth JWT caching const zbc = new ZBClient({ camundaCloud: { clientId: \u0026#39;yStuGvJ6a1RQhy8DQpeXJ80yEpar3pXh\u0026#39;, clientSecret: \u0026#39;WZahIGHjyj0-oQ7DZ_aH2wwNuZt5O8Sq0ZJTz0OaxfO7D6jaDBZxM_Q-BHRsiGO_\u0026#39;, clusterId: \u0026#39;103ca930-6da6-4df7-aa97-941eb1f85040\u0026#39;, cacheDir: \u0026#39;./tokens\u0026#39; } })     Environmentalizing Camunda Cloud To use Camunda Cloud, set the environment variables:\nZEEBE_ADDRESS # Set with \u0026#34;Zeebe Cluster Id\u0026#34; value ZEEBE_CLIENT_ID # Set with \u0026#34;clientId\u0026#34; value ZEEBE_CLIENT_SECRET # Set with \u0026#34;clientSecret\u0026#34; value Setting only these three OAuth values is interpreted by the client as necessary and sufficient for Camunda Cloud, and it will enable TLS and correctly set the OAuth token audience and Authorization URL.\nOptionally, set a custom token cache directory:\nZEEBE_TOKEN_CACHE_DIR "
},
{
	"uri": "http://example.org/zbclient/overview/configuration/",
	"title": "Configuration Strategies",
	"tags": [],
	"description": "",
	"content": "The workers created from the Zeebe client inherit the client's settings, allowing you to consolidate your configuration. At the same time, you can override those settings for any worker - so you have convenience and flexibility.\nZero-conf constructor vs configuration in code You can provide configuration to the ZBClient explicitly in your code - via the constructor - or via environment variables.\nExplicit configuration in code is quick and easy, and makes sense when you are first experimenting with Zeebe.\nWe recommend, however, that ultimately you use the zero-conf constructor, and provide all the configuration via environment variables, docker-compose.yml, or a K8s config map. This environmentalizes your configuration, making your code portable.\nWhen you deploy your application to a test, staging, or production environment, no changes are required in your code: you will be testing the exact code you run in production, and you can use configuration management tools to handle the different environments.\nNote that any explicit configuration in code overrides configuration from the environment - with one exception: the log level can be overridden from the environment.\n"
},
{
	"uri": "http://example.org/zbclient/grpc/grpc-events/",
	"title": "ZBClient gRPC channel events",
	"tags": [],
	"description": "",
	"content": "ZBClient gRPC channel events The ZBClient notifies on gRPC channel connection failure and reconnection. In addition to wrapping every single operation, you can use this feature to write alerting or custom behavior based on the underlying connection status.\nOne thing to bear in mind is that ZBClient operations will throw if they encounter an error. However, there is no opportunity to be alerted to a network failure until you try an operation.\nThe ZBClient gRPC channel events allow you to detect and react to network disruption independent of operations.\nThere are two interfaces to the ZBClient gRPC events: callbacks and events.\nonReady and onConnectionError callbacks The onReady callback is called when the ZBClient gRPC connection is initially established, and every time it is re-established after it is disconnected.\nNote that the ZBClient constructor immediately issues a topology command to the broker to provoke an error or prove the connection. Without this, the channel status is unknown until the first command is issued.\nThe onConnectionError callback is called when the gRPC channel is disconnected.\nPass in callbacks to the ZBClient constructor to react on these events:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ onReady: () =\u0026gt; console.log(\u0026#39;Ready for action!\u0026#39;), onConnectionError: () =\u0026gt; console.log(\u0026#39;Boo! The gRPC connection failed!\u0026#39;) })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ onReady: () =\u0026gt; console.log(\u0026#39;Ready for action!\u0026#39;), onConnectionError: () =\u0026gt; console.log(\u0026#39;Boo! The gRPC connection failed!\u0026#39;) })     \u0026lsquo;ready\u0026rsquo; and \u0026lsquo;connectionError\u0026rsquo; events The ZBClient class extends EventEmitter. As well as invoking any callback handlers passed to the constructor, the ZBClient emits the ready and connectionError events.\nThis means that you can do things like attach one-time listeners, or write a module that contains reusable connection logic and wraps a ZBClient instance. For an example of this, see the zeebe-canaryize package.\ngRPC status jitter and connectionTolerance When the gRPC connection fails, as the gRPC channel tries to reconnect, it rapidly cycles between connected / disconnected before settling on disconnected. To avoid calling the onReady and onConnectionError callbacks rapidly in multiple succession and emitting a stream of events, the client debounces the channel status transitions, and requires the channel to be in the new state for 3 seconds before calling it.\nThe default window of three seconds is based on observation of production systems using specific proxies. You might find that you need a different window for connection tolerance, in which case you can pass in another value for connectionTolerance in the ZBClient constructor:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient({ connectionTolerance: 3000 })   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient({ connectionTolerance: 3000 })     "
},
{
	"uri": "http://example.org/typesafety/examples/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Building Type-safe applications  /** * This TypeScript example makes use of Generic typing to provide intellisense and type-safety * for the variables. If you don\u0026#39;t supply any Generic types (in angle brackets \u0026lt;\u0026gt;), * the type of variables will be `any`. That also works fine, just with less safety. */ import { ZBClient } from \u0026#39;zeebe-node\u0026#39; import type { CreateWorkflowInstanceWithResultResponse } from \u0026#39;zeebe-node\u0026#39; // TS 3.8+  const zbc = new ZBClient() interface UserRecord { userid: number name: string } interface FinalState extends UserRecord { approved: boolean } async function processUser(user: UserRecord): Promise\u0026lt;CreateWorkflowInstanceWithResultResponse\u0026lt;FinalState\u0026gt;\u0026gt; { try { const res = await zbc.createWorkflowInstanceWithResult\u0026lt;UserRecord, FinalState\u0026gt;(\u0026#39;user-something-process\u0026#39;, user) return res } catch (e) { console.log(`There was an error running the \u0026#39;user-something-process\u0026#39;!`) throw e } } processUser({ userid: 34, name: \u0026#39;Jane Doe\u0026#39; }) .then(({variables}) =\u0026gt; console.log(`User ${variables.name}approved: `, variables.approved)) .catch(e =\u0026gt; console.log(e))   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function processUser(user) { try { const res = await zbc.createWorkflowInstanceWithResult(\u0026#39;user-something-process\u0026#39;, user) return res } catch (e) { console.log(`There was an error running the \u0026#39;user-something-process\u0026#39;!`) throw e } } processUser({ userid: 34, name: \u0026#39;Jane Doe\u0026#39; }) .then(({variables}) =\u0026gt; console.log(`User ${variables.name}approved: `, variables.approved)) .catch(e =\u0026gt; console.log(e))     "
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]