[
{
	"uri": "http://example.org/introduction/zeebe-node/",
	"title": "Zeebe Node",
	"tags": [],
	"description": "",
	"content": "The zeebe-node npm package is an open-source library for creating Node.js Zeebe client applications.\nIt was developed internally at an early-adopter of Zeebe - Credit Sense in Australia - by Josh Wulf. Credit Sense contributed it to the community by making it open-source, and it has gone on to become a popular way to write Zeebe applications.\nIt is written in TypeScript, and can be used with TypeScript or JavaScript.\n"
},
{
	"uri": "http://example.org/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Introduction "
},
{
	"uri": "http://example.org/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Installation Adding the Zeebe Node client to your Node.js project.\n"
},
{
	"uri": "http://example.org/quickstart/",
	"title": "Quick Start",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Quick Start Get a basic Zeebe application running in next to no time.\n"
},
{
	"uri": "http://example.org/zbclient/",
	"title": "ZBClient",
	"tags": [],
	"description": "",
	"content": " Chapter 3 ZBClient Using the ZBClient to interact with a Zeebe broker.\n"
},
{
	"uri": "http://example.org/installation/install/install/",
	"title": "Install",
	"tags": [],
	"description": "",
	"content": " The Zeebe Node client is available via npm.\nAdd to an existing project  npm i zeebe-node    Create a new Node.js project  mkdir myproject cd myproject npm init -y npm i zeebe-node    Make it a TypeScript project  npm i -g typescript tsc --init    "
},
{
	"uri": "http://example.org/",
	"title": "Zeebe Node.js Client Guide",
	"tags": [],
	"description": "",
	"content": " Zeebe Node.js Client Guide "
},
{
	"uri": "http://example.org/introduction/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": " Intended Audience This guide is intended for Node.js developers who want to develop Zeebe client applications in JavaScript or TypeScript.\nFamiliarity with ES6 JavaScript or the TypeScript programming language, Node.js, and a working development environment are assumed.\nConfiguring your TypeScript transpilation is out of scope. For that, consult the TypeScript documentation.\nWhat this guide covers This guide walks you through using the JavaScript client for Zeebe, giving you the practical steps to write a fully-fledged Zeebe client application using either ES6 JavaScript or TypeScript.\nIf you want to:\n Evaluate whether Zeebe is a good fit as a solution to your business problem. Build a POC using Zeebe and Node.js. Go to production with a Zeebe solution written in JavaScript / TypeScript.  You\u0026rsquo;ve come to the right place.\nZeebe Broker You will need a running Zeebe broker during development. For instructions on installing a broker for local development and testing, consult the Zeebe broker documentation.\nCode language Code samples are presented in both JavaScript (ES6) and TypeScript, in tabs:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     "
},
{
	"uri": "http://example.org/zbclient/connection/",
	"title": "Connection to the Zeebe broker",
	"tags": [],
	"description": "",
	"content": " The ZBClient class establishes a connection to a Zeebe broker cluster, and is used to send commands to the broker.\nConceptually, the ZBClient \u0026ldquo;talks to a broker\u0026rdquo;. In practice, the ZBClient talks to a gateway, which handles routing and load-balancing in the broker cluster. This means that you provide a gateway address to the ZBClient. In a development setup, you may have a single broker node with the embedded gateway enabled. In this case you can use the simplest constructor:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     Zero-conf constructor vs explicit gateway address In the absence of any other arguments or environment variables, the ZBClient will communicate with a gateway at 127.0.0.1 on port 26500.\nYou can explicitly provide an address to the constructor if you want. The following examples are functionally equivalent:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() const zbc1 = new ZBClient(\u0026#39;127.0.0.1\u0026#39;) const zbc1 = new ZBClient(\u0026#39;127.0.0.1:26500\u0026#39;) const zbc2 = new ZBClient(\u0026#39;localhost\u0026#39;) const zbc3 = new ZBClient(\u0026#39;localhost:26500\u0026#39;)  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() const zbc1 = new ZBClient(\u0026#39;127.0.0.1\u0026#39;) const zbc1 = new ZBClient(\u0026#39;127.0.0.1:26500\u0026#39;) const zbc2 = new ZBClient(\u0026#39;localhost\u0026#39;) const zbc3 = new ZBClient(\u0026#39;localhost:26500\u0026#39;)     We recommend, however, that you use the zero-conf constructor, with no gateway address. This allows you to environmentalize your configuration. When you deploy your application to production (or a test or staging environment), no changes are required in your code.\nEnvironmentalizing the connection The ZBClient constructor examines the environment for the variable ZEEBE_ADDRESS. By setting this variable in your various environments (for example via docker-compose.yml or a K8s config map), and using the zero-conf constructor, your code is portable.\nFor example, given an index.js|ts file like this:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     You can run against a local broker simply with:\n node index.js    And run the same code against a remote server running on port 80 on zeebe.test.mydomain.com with:\n ZEEBE_ADDRESS=zeebe.test.mydomain.com:80 node index.js    "
},
{
	"uri": "http://example.org/quickstart/quickstart/",
	"title": "Zeebe Node Quickstart",
	"tags": [],
	"description": "",
	"content": " Prerequisites  Node.js / npm A Zeebe broker running locally (refer to the broker documentation).  Import the Zeebe Node library Create an index.js file (or index.ts for TypeScript).\nEdit the file, and import the Zeebe Node library:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39;   const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;)     Create a ZBClient  import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     This establishes a connection to a Zeebe broker running on localhost:26500. This is the default when no arguments are passed to the constructor and no environment variables are set.\nThe connection is eager. This will throw if a broker connection cannot be established - although at this point, this program exits before the connection timeout is reached.\nQuery the broker topology The ZBClient.topology() method queries the broker topology. It returns a Promise of a broker topology object.\nOperations involving the broker are asynchronous. They involve network calls, so they return Promises that need to be awaited, or composed using Promise.then.\nHere we query the broker topology using the Promise interface:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() zbc.topology() .catch(console.error) .then(res =\u0026gt; console.log(JSON.stringify(res, null, 2)))  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() zbc.topology() .catch(console.error) .then(res =\u0026gt; console.log(JSON.stringify(res, null, 2)))     For the rest of this guide, we will mostly be using the async/await approach to Promise handling in examples.\nHere is the same code to query the broker topology, written using async/await syntax:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { const res = await zbc.topology() console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { const res = await zbc.topology() console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     You can use either style in your code.\nOutput: Query the broker topology If the broker is running and accessible, you will see something like the following:\n{ \u0026quot;brokers\u0026quot;: [ { \u0026quot;partitions\u0026quot;: [ { \u0026quot;partitionId\u0026quot;: 1, \u0026quot;role\u0026quot;: \u0026quot;LEADER\u0026quot; } ], \u0026quot;nodeId\u0026quot;: 0, \u0026quot;host\u0026quot;: \u0026quot;172.24.0.2\u0026quot;, \u0026quot;port\u0026quot;: 26501 } ], \u0026quot;clusterSize\u0026quot;: 1, \u0026quot;partitionsCount\u0026quot;: 1, \u0026quot;replicationFactor\u0026quot;: 1 }  Note: if the broker is running in Docker, the host IP address reported by the topology command is the internal Docker network IP of the broker.\nNetwork errors and automatic retries If the broker is not started, or is not accessible to your client, you will see a stream of errors - similar to the one below - that slow down over time.\n{\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/tmp/myproject/node_modules/zeebe-node/dist/zb/ZBClient.js:382\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;14 UNAVAILABLE: failed to connect to all addresses\u0026quot;,\u0026quot;pollMode\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;taskType\u0026quot;:\u0026quot;ZBClient\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-11 22:39:32PM\u0026quot;,\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-11T12:39:32.155Z\u0026quot;} {\u0026quot;context\u0026quot;:\u0026quot;/Users/sitapati/workspace/tmp/myproject/node_modules/zeebe-node/dist/zb/ZBClient.js:374\u0026quot;,\u0026quot;level\u0026quot;:50,\u0026quot;message\u0026quot;:\u0026quot;gRPC connection is in failed state. Attempt 5. Retrying in 5s...\u0026quot;,\u0026quot;pollMode\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;taskType\u0026quot;:\u0026quot;ZBClient\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2019 Nov-11 22:39:37PM\u0026quot;,\u0026quot;timestamp\u0026quot;:\u0026quot;2019-11-11T12:39:37.159Z\u0026quot;}  These are due to the Zeebe Node client\u0026rsquo;s built-in backoff-retry logic for network-related errors. The client automatically retries to establish the connection until it connects, or retries are exhausted.\nYou can disable automatic retries if you want network errors to bubble up immediately to your code, and write your own logic to handle them. See the later section on the ZBClient for more details.\nLogs The client logs to the console by default (you can inject a replacement), using a structured JSON format - ndjson. To view the log output in a human-readable format, you can use pino-pretty.\nInstall pino-pretty globally:\n npm i -g pino-pretty     Now, pipe your program\u0026rsquo;s output through pino-pretty:\n node index.js | pino-pretty     Log messages will now be formatted for your viewing pleasure:\n[2019 Nov-11 23:43:48PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/tmp/myproject/node_modules/zeebe-node/dist/zb/ZBClient.js:382\u0026quot; message: \u0026quot;14 UNAVAILABLE: failed to connect to all addresses\u0026quot; pollMode: \u0026quot;\u0026quot; taskType: \u0026quot;ZBClient\u0026quot; [2019 Nov-11 23:43:53PM] ERROR: context: \u0026quot;/Users/sitapati/workspace/tmp/myproject/node_modules/zeebe-node/dist/zb/ZBClient.js:374\u0026quot; message: \u0026quot;gRPC connection is in failed state. Attempt 10. Retrying in 5s...\u0026quot; pollMode: \u0026quot;\u0026quot; taskType: \u0026quot;ZBClient\u0026quot;  Deploy a Workflow The next task is to deploy a workflow to the broker.\nThe method ZBClient.deployWorkflow() takes a path to a .bpmn file, and deploys that BPMN file to the broker, returning a Promise of a broker response - a DeployWorkflowResponse.\nHere is the sample workflow that we will be using:\nIt has a single task in it.\nDownload the sample bpmn file from this bpmn-sample GitHub repository.\nIf you are using JavaScript or transpiling TypeScript in-place (outputting the .js files next to the .ts source files), then put the .bpmn file in the same directory as your index file. You will need to use the path ./sample.bpmn.\nIf you are transpiling your TypeScript from a source directory to an output directory, then put the .bpmn file in the directory above your source directory. You will need to use the path ../sample.bpmn.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { const res = await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { const res = await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     Output: Deploy a Workflow You will see output similar to the following:\n{ \u0026quot;workflows\u0026quot;: [ { \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;version\u0026quot;: 1, \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813685249\u0026quot;, \u0026quot;resourceName\u0026quot;: \u0026quot;sample.bpmn\u0026quot; } ], \u0026quot;key\u0026quot;: \u0026quot;2251799813685250\u0026quot; }  The workflow has been deployed to the broker, and you can now start an instance of the workflow, using its bpmnProcessId - \u0026ldquo;sample-process\u0026rdquo; (this is defined in the .bpmn file).\nCreate a Workflow Instance The method ZBClient.createWorkflowInstance() creates (and starts) a workflow instance. It takes a BPMN Process Id and an initial variables object, and returns a Promise of a CreateWorkflowInstance response.\nThere is no problem leaving the deployWorkflow command in the code - the broker will not update the deployment if the file has not changed since the last deployment, and it ensures that the workflow definition we are about to start an instance of is, in fact, deployed.\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstance(\u0026#39;sample-process\u0026#39;, {}); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstance(\u0026#39;sample-process\u0026#39;, {}); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     Output: Create a Workflow Instance You will see output similar to the following:\n{ \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813685249\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;version\u0026quot;: 1, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813685252\u0026quot; }  An instance of the workflow has been started.\nCreate a Worker A worker is a process that subscribes to a task type on the broker, polling for available jobs of that task type. When jobs of that task type are available, the broker streams them to the worker in response to its polling request. The workflow\u0026rsquo;s job handler is invoked for each available job.\nThe method ZBClient.createWorker creates a new worker. It takes an optional worker id for tracing, a task type, and a job handler callback function. If the worker id is null, the library will assign a UUID.\nCreate a new file named worker.js (worker.ts for TypeScript).\nEdit the content like this:\n import { ZBClient } from \u0026#34;zeebe-node\u0026#34;; const zbc = new ZBClient(); zbc.createWorker(null, \u0026#34;sample-task\u0026#34;, (job, complete) =\u0026gt; { console.log(JSON.stringify(job, null, 2)); // Business logic complete.success(); });  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient(); zbc.createWorker(null, \u0026#34;sample-task\u0026#34;, (job, complete) =\u0026gt; { console.log(JSON.stringify(job, null, 2)); // Business logic complete.success(); });     When you run this, the worker polls the broker for jobs of type \u0026lsquo;sample-task\u0026rsquo;, and gets the job from the workflow you created in a previous step.\nOutput: Create a Worker You will see output similar to the following:\n{ \u0026quot;key\u0026quot;: \u0026quot;2251799813686445\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;sample-task\u0026quot;, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813686440\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;workflowDefinitionVersion\u0026quot;: 1, \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813686430\u0026quot;, \u0026quot;elementId\u0026quot;: \u0026quot;ServiceTask_1aj1tsb\u0026quot;, \u0026quot;elementInstanceKey\u0026quot;: \u0026quot;2251799813686444\u0026quot;, \u0026quot;customHeaders\u0026quot;: {}, \u0026quot;worker\u0026quot;: \u0026quot;559fe180-c860-44ba-a6c5-8d32d6b9e026\u0026quot;, \u0026quot;retries\u0026quot;: 3, \u0026quot;deadline\u0026quot;: \u0026quot;1574076501831\u0026quot;, \u0026quot;variables\u0026quot;: {} }  This is the job object that is received by the worker. Your worker can perform any side-effects and any calculations it needs to, and post any updates to the job variables.\nYour worker is sitting there polling for more work, so you can experiment with starting more workflows. Hit Ctrl-C to kill the worker when you are ready to move on.\nUpdate the job This next step requires 0.22.0-alpha1 or later of the broker, and v0.22.0-alpha.1 or later of the Node client. We are going to use the createWorkflowInstanceWithResult() method of the client to await the outcome of the workflow. This method was introduced with that version and does not work in earlier versions.\nFirst, modify your worker like this:\n import { ZBClient } from \u0026#34;zeebe-node\u0026#34;; const zbc = new ZBClient(); zbc.createWorker(null, \u0026#34;sample-task\u0026#34;, (job, complete) =\u0026gt; { console.log(JSON.stringify(job, null, 2)); // Business logic complete.success({ updateId: \u0026#39;some-uuid\u0026#39; }); });  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient(); zbc.createWorker(null, \u0026#34;sample-task\u0026#34;, (job, complete) =\u0026gt; { console.log(JSON.stringify(job, null, 2)); // Business logic complete.success({ updateId: \u0026#39;some-uuid\u0026#39; }); });     Here, we update the workflow variables from the worker. This update will be merged with the other variables in the workflow and will be the job variables that workers servicing tasks later in the process receive. There is only one task in our sample workflow, so we will use a method call that starts a workflow and awaits the result to inspect the variable state after our worker does its thing.\nStart the worker now, and modify index.js|ts to be this:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstanceWithResult(\u0026#39;sample-process\u0026#39;, { requestId: \u0026#39;someRequestId\u0026#39; }); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient() async function main() { try { await zbc.deployWorkflow(\u0026#39;./sample.bpmn\u0026#39;) const res = await zbc.createWorkflowInstanceWithResult(\u0026#39;sample-process\u0026#39;, { requestId: \u0026#39;someRequestId\u0026#39; }); console.log(JSON.stringify(res, null, 2)) } catch (e) { console.error(e) } } main()     Output: Update the job You will see output similar to the following in the worker:\n{ \u0026quot;key\u0026quot;: \u0026quot;2251799813686671\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;sample-task\u0026quot;, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813686665\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;workflowDefinitionVersion\u0026quot;: 1, \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813686430\u0026quot;, \u0026quot;elementId\u0026quot;: \u0026quot;ServiceTask_1aj1tsb\u0026quot;, \u0026quot;elementInstanceKey\u0026quot;: \u0026quot;2251799813686670\u0026quot;, \u0026quot;customHeaders\u0026quot;: {}, \u0026quot;worker\u0026quot;: \u0026quot;819f09a4-7fde-4782-808d-9ed86c8ee363\u0026quot;, \u0026quot;retries\u0026quot;: 3, \u0026quot;deadline\u0026quot;: \u0026quot;1574079338555\u0026quot;, \u0026quot;variables\u0026quot;: { \u0026quot;requestId\u0026quot;: \u0026quot;someRequestId\u0026quot; } }  We created the workflow instance with variable requestId set to someRequestId, and you can see that your worker receives this in the job variables.\nWhen the worker completes the job, it sends back an update: it sets updateId to some-uuid. In your process that creates and awaits the workflow, you will see something similar to the following:\n{ \u0026quot;workflowKey\u0026quot;: \u0026quot;2251799813686430\u0026quot;, \u0026quot;bpmnProcessId\u0026quot;: \u0026quot;sample-process\u0026quot;, \u0026quot;version\u0026quot;: 1, \u0026quot;workflowInstanceKey\u0026quot;: \u0026quot;2251799813686665\u0026quot;, \u0026quot;variables\u0026quot;: { \u0026quot;updateId\u0026quot;: \u0026quot;some-uuid\u0026quot;, \u0026quot;requestId\u0026quot;: \u0026quot;someRequestId\u0026quot; } }  The workflow variables were updated.\nSummary In this Quickstart you deployed a workflow, created instances of that workflow, created a worker to service the single task in the workflow, updated job variables, and awaited a workflow\u0026rsquo;s outcome.\nThis is 80% of what you\u0026rsquo;ll be doing with the Zeebe Node client in your application.\nThe rest of this guide goes into more depth on each of these aspects, and also covers the other methods that are available.\n"
},
{
	"uri": "http://example.org/introduction/not-rest/",
	"title": "Zeebe client applications",
	"tags": [],
	"description": "",
	"content": " Zeebe is a highly-scalable, cloud-native microservices orchestration engine that uses BPMN to orchestrate microservices.\nPolling model Zeebe clients communicate with a Zeebe broker cluster through a gateway. Communication between the JavaScript client code and the gateway is over gRPC. That means that your client applications poll the gateway for available tasks. The Zeebe broker does not invoke your microservices over REST. If you come from a REST architecture background, or have an existing REST microservices architecture that you want to orchestrate, you should take the time to understand the Zeebe model as it is, before trying to figure out how to use it with RESTful services. It is definitely possible, but you need to wire it up to work.\nThink of it like this: your Zeebe worker, written in JavaScript, subscribes to a task type on the gateway. It then runs in a loop, polling the gateway for that task type. When jobs of that task type are available, the gateway returns them to the worker. If you have an existing RESTful microservice that you want to invoke for jobs of that task type, then your Zeebe worker can invoke it. And that\u0026rsquo;s how you wire up Zeebe with existing RESTful microservices.\nYou could do something like create a worker that subscribes to many task types and has a map for the task type to the REST endpoint that should be invoked for it.\nThe important thing to understand is that workers subscribe to a task type, and poll for jobs of that task type. So it is a pull model, rather than the push model of REST, where the broker would invoke a REST service.\nThe pull model means that you can scale the workers without configuring routing or load-balancing, as you would need to do if it were a push model.\nIf you are writing a system from scratch, then you can put your business logic directly in a polling worker - or you can put the business logic in a REST endpoint if you need to reuse it from other places, and wrap the REST call in a Zeebe worker.\n"
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]