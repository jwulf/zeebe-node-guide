[
{
	"uri": "http://example.org/introduction/zeebe-node/",
	"title": "Zeebe Node",
	"tags": [],
	"description": "",
	"content": "The zeebe-node npm package is an open-source library for creating Node.js Zeebe client applications.\n"
},
{
	"uri": "http://example.org/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Introduction "
},
{
	"uri": "http://example.org/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Installation Adding the Zeebe Node client to your Node.js project.\n"
},
{
	"uri": "http://example.org/installation/install/install/",
	"title": "Install",
	"tags": [],
	"description": "",
	"content": " Add to an existing project  npm i zeebe-node    Create a new Node.js project "
},
{
	"uri": "http://example.org/",
	"title": "Zeebe Node.js Client Guide",
	"tags": [],
	"description": "",
	"content": " Zeebe Node.js Client Guide "
},
{
	"uri": "http://example.org/introduction/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": " Intended Audience This guide is intended for Node.js developers who want to develop Zeebe client applications in JavaScript or TypeScript.\nFamiliarity with ES6 JavaScript or the TypeScript programming language, Node.js, and a working development environment are assumed.\nWhat this guide covers This guide walks you through using the JavaScript client for Zeebe, giving you the practical steps to write a fully-fledged Zeebe client application using either ES6 JavaScript or TypeScript.\nIf you want to:\n Evaluate whether Zeebe is a good fit as a solution to your business problem. Build a POC using Zeebe and Node.js. Go to production with a Zeebe solution written in JavaScript / TypeScript.  You\u0026rsquo;ve come to the right place.\nZeebe Broker You will need a running Zeebe broker during development. For instructions on installing a broker for local development and testing, consult the Zeebe broker documentation.\nCode language Code samples are presented in both JavaScript (ES6) and TypeScript, in tabs:\n import { ZBClient } from \u0026#39;zeebe-node\u0026#39; const zbc = new ZBClient()  const { ZBClient } = require(\u0026#39;zeebe-node\u0026#39;) const zbc = new ZBClient()     "
},
{
	"uri": "http://example.org/introduction/not-rest/",
	"title": "Zeebe client applications",
	"tags": [],
	"description": "",
	"content": " Zeebe is a highly-scalable, cloud-native microservices orchestration engine that uses BPMN to orchestrate microservices.\nPolling model Zeebe clients communicate with a Zeebe broker cluster through a gateway. Communication between the JavaScript client code and the gateway is over gRPC. That means that your client applications poll the gateway for available tasks. The Zeebe broker does not invoke your microservices over REST. If you come from a REST architecture background, or have an existing REST microservices architecture that you want to orchestrate, you should take the time to understand the Zeebe model as it is, before trying to figure out how to use it with RESTful services. It is definitely possible, but you need to wire it up to work.\nThink of it like this: your Zeebe worker, written in JavaScript, subscribes to a task type on the gateway. It then runs in a loop, polling the gateway for that task type. When jobs of that task type are available, the gateway returns them to the worker. If you have an existing RESTful microservice that you want to invoke for jobs of that task type, then your Zeebe worker can invoke it. And that\u0026rsquo;s how you wire up Zeebe with existing RESTful microservices.\nYou could do something like create a worker that subscribes to many task types and has a map for the task type to the REST endpoint that should be invoked for it.\nThe important thing to understand is that workers subscribe to a task type, and poll for jobs of that task type. So it is a pull model, rather than the push model of REST, where the broker would invoke a REST service.\nThe pull model means that you can scale the workers without configuring routing or load-balancing, as you would need to do if it were a push model.\nIf you are writing a system from scratch, then you can put your business logic directly in a polling worker - or you can put the business logic in a REST endpoint if you need to reuse it from other places, and wrap the REST call in a Zeebe worker.\n"
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]